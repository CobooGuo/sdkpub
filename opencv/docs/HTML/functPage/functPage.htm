<HTML>
<HEAD>
<TITLE>Source File: cv.h</TITLE>
</HEAD>
<BODY BGCOLOR=white TEXT=black>
<PRE>
<FONT COLOR=darkgreen>/*M///////////////////////////////////////////////////////////////////////////////////////
//
//  IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
//
//  By downloading, copying, installing or using the software you agree to this license.
//  If you do not agree to this license, do not download, install,
//  copy or use the software.
//
//
//                        Intel License Agreement
//                For Open Source Computer Vision Library
//
// Copyright( C) 2000, Intel Corporation, all rights reserved.
// Third party copyrights are property of their respective owners.
//
// Redistribution and use in source and binary forms, with or without modification,
// are permitted provided that the following conditions are met:
//
//   * Redistribution's of source code must retain the above copyright notice,
//     this list of conditions and the following disclaimer.
//
//   * Redistribution's in binary form must reproduce the above copyright notice,
//     this list of conditions and the following disclaimer in the documentation
//     and/or other materials provided with the distribution.
//
//   * The name of Intel Corporation may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
//
// This software is provided by the copyright holders and contributors "as is" and
// any express or implied warranties, including, but not limited to, the implied
// warranties of merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the Intel Corporation or contributors be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
//(including, but not limited to, procurement of substitute goods or services;
// loss of use, data, or profits; or business interruption) however caused
// and on any theory of liability, whether in contract, strict liability,
// or tort(including negligence or otherwise) arising in any way out of
// the use of this software, even if advised of the possibility of such damage.
//
//M*/</FONT>

<FONT COLOR=darkblue>#ifndef _CV_H_</FONT>
<FONT COLOR=darkblue>#define _CV_H_</FONT>

<FONT COLOR=darkblue>#ifndef __CV_DEFINE_USER_LIST__</FONT>

<FONT COLOR=darkblue>#include &lt;ipl.h&gt;</FONT>

<FONT COLOR=darkblue>#include "cvpixelaccess.h"</FONT>

<FONT COLOR=darkblue>#ifndef _CVTYPES_H_</FONT>
<FONT COLOR=darkblue>#include "cvtypes.h"</FONT>
<FONT COLOR=darkblue>#endif</FONT>
<FONT COLOR=darkblue>#include "cverror.h"</FONT>

<FONT COLOR=darkblue>#endif <FONT COLOR=darkgreen>/* __CV_DEFINE_USER_LIST__ */</FONT></FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                    Function definition                                 *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCreateImageHeader
//    Purpose: allocates IplImage structure, initializes and returns it
//    Context:
//    Parameters:
//      size - image size(width and height)
//      depth- image depth
//      channels - number of channels.
//    Returns:
//      this call is short form of
//         iplCreateImageHeader( channels, 0, depth, channels == 1 ? "GRAY" :
//                               channels == 3 || channels == 4 ? "RGB" : "",
//                               channels == 1 ? "GRAY" : channels == 3 ? "BGR" :
//                               channels == 4 ? "BGRA" : "",
//                               IPL_DATA_ORDER_PIXEL, IPL_ORIGIN_TL, 4,
//                               size.width, size.height,
//                               0,0,0,0);
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  cvCreateImageHeader<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> size<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> depth<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> channels <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCreateImage
//    Purpose: creates header and allocates data
//    Context:
//    Parameters:
//      size - image size(width and height)
//      depth- image depth
//      channels - number of channels.
//    Returns:
//      this call is short form of
//         header = cvCreateImageHeader(size,depth,channels);
//         cvCreateImageData(header);
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  cvCreateImage<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> size<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> depth<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> channels <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvReleaseImageHeader
//    Purpose: releases header
//    Context:
//    Parameters:
//        image - released image header
//    Returns:
//      this call is short form of
//         if( image )
//         {
//              iplDeallocate( *image, IPL_IMAGE_HEADER | IPL_IMAGE_ROI );
//              *image = 0;
//         }
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvReleaseImageHeader<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>**</FONT> image <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvReleaseImage
//    Purpose: releases header and image data
//    Context:
//    Parameters:
//      image - released image
//    Returns:
//      this call is short form of
//         if( image )
//         {
//              iplDeallocate( *image, IPL_IMAGE_ALL );
//              *image = 0;
//         }
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvReleaseImage<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>**</FONT> image <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCreateImageData
//    Purpose: allocates image data
//    Context:
//    Parameters:
//        image - image header
//    Returns:
//      this call is short form of
//         if( image->depth == IPL_DEPTH_32F )
//         {
//              iplAllocateImageFP( image, 0, 0 );
//         }
//         else
//         {
//              iplAllocateImage( image, 0, 0 );
//         }
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCreateImageData<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvReleaseImageData
//    Purpose: releases image data
//    Context:
//    Parameters:
//      image - image header
//    Returns:
//      this call is short form of
//         iplDeallocate( image, IPL_IMAGE_DATA );
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvReleaseImageData<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSetImageData
//    Purpose: set pointer to data and step parameter to given values
//    Context:
//    Parameters:
//      image - image header
//      data  - user data
//      step  - distance between raster lines in bytes
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSetImageData<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> data<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> step <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSetImageCOI
//    Purpose: set channel of interest to given value.
//    Context:
//    Parameters:
//      image - image header
//      coi   - channel of interest
//    Returns:
//    Notes:
//      If roi is NULL and coi != 0, roi is allocated.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSetImageCOI<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> coi <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSetImageROI
//    Purpose: set image ROI to given rectangle
//    Context:
//    Parameters:
//      image - image header
//      rect  - ROI rectangle
//    Returns:
//    Notes:
//       If roi is NULL and rect is not equal to a whole image, roi is allocated.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSetImageROI<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvRect</FONT> rect <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGetImageRawData
//    Purpose: fills output variables with image parameters
//    Context:
//    Parameters:
//      image - image header
//      data  - pointer to top-left corner of ROI
//      step  - = image->widthStep(full width of raster line)
//      roi_size - width and height of ROI
//    Returns:
//    Notes:
//      All the output parameters are optional
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvGetImageRawData<FONT COLOR=black>(</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>uchar</FONT><FONT COLOR=black>**</FONT> data<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> step<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT><FONT COLOR=black>*</FONT> roi_size <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvInitImageHeader
//    Purpose: initializes image header structure without memory allocation
//    Context:
//    Parameters:
//      image - image header. User allocates it manually(e.g. on stack)
//      size  - width and height of the image
//      depth - image depth
//      channels - number of channels
//      origin - IPL_ORIGIN_TL or IPL_ORIGIN_BL.
//      align - alignment for raster lines
//      clear - if 1, header is cleared before it is initialized.
//    Returns:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvInitImageHeader<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> size<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> depth<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>int</FONT> channels<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> origin<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> align<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> clear <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCopyImage
//    Purpose: copies entire image(no ROI is considered) to another
//    Context:
//    Parameters:
//      src - source image
//      dst - destination image
//    Returns:
//    Notes:
//      if destination image is smaller, its data is reallocated.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCopyImage<FONT COLOR=black>(</FONT><FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGetImageROI
//    Purpose: return region of interest of given image(if image doesn't have ROI then
//             return realy size of element)
//    Context:
//    Parameters:
//      img - source image
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvRect</FONT> cvGetImageROI<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCloneImage
//    Purpose: creates copy of source image(allocates image data, ROI and maskROI if
//             it present in source image)
//    Context:
//    Parameters:
//      img - source image
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> cvCloneImage<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src <FONT COLOR=black>);</FONT>



<FONT COLOR=darkgreen>/****************************************************************************************\
*                                     Pyramids                                           *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvPyrUp
//    Purpose: performs upsampling by factor 2 of the image with subsequent
//             Gaussian smoothing.
//    Context:
//    Parameters:
//      src - source image
//      dst - destination image(must have twice larger width and height than source image)
//      filter - filter applied. Only IPL_GAUSSIAN_5x5 is allowed.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvPyrUp<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT>
                       IplFilter filter <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>IPL_GAUSSIAN_5x5<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvPyrDown
//    Purpose: performs downsampling by factor 2 of the image with prior Gaussian.
//    Context:
//    Parameters:
//        src - source image
//        dst - destination image(must have twice smaller width and height than
//                                 source image)
//        filter - filter applied. Only IPL_GAUSSIAN_5x5 is allowed.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvPyrDown<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT>
                         IplFilter filter <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>IPL_GAUSSIAN_5x5<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvPyrSegmentation
//    Purpose: segments image by pyramid-linking
//    Context:
//    Parameters:
//      src - source image
//      dst - destination image
//      storage - pointer to the memory storage
//      comp - pointer to the sequence of the connected components
//      level - number of level to the pyramid costruction
//      threshold1 - the first segmentation threshold
//      threshold2 - the second segmentation threshold
//    Notes:
//             Source and destination image must be equal types and planes
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvPyrSegmentation<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT>
                               <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT>
                               <FONT COLOR=darkmagenta>CvMemStorage</FONT> <FONT COLOR=black>*</FONT>storage<FONT COLOR=black>,</FONT>
                               <FONT COLOR=darkmagenta>CvSeq</FONT> <FONT COLOR=black>**</FONT>comp<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>int</FONT> level<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> threshold1<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>double</FONT> threshold2 <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                              Derivative calculation                                    *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSobel
//    Purpose: calculates an image derivative d^(xorder+yorder)I/((dx)^xorder)*(dy^yoder))
//             by convolving the image with extended Sobel operators.
//             No scaling is performed.
//
//             |-1 -2 -1|     |-1 0 1|
//             | 0  0  0| and |-2 0 2| are partial cases of it.
//             | 1  2  1|     |-1 0 1|
//
//             First one corresponds to xorder = 0, yorder = 1, apertureSize = 3,
//             And the second corresponds to xorder = 1, yorder = 0, apertureSize = 3.
//    Context:
//    Parameters:
//      src    - source image
//      deriv  - destination derivative image
//      xorder - order of x derivative
//      yorder - order of y derivative
//      apertureSize - size of colvolution operator. Must be odd: 3, 5, ...
//    Returns:
//    Notes:
//      The function uses replicatation border mode
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvSobel<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT>
                     <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> deriv<FONT COLOR=black>,</FONT>
                     <FONT COLOR=blue>int</FONT> xorder<FONT COLOR=black>,</FONT>
                     <FONT COLOR=blue>int</FONT> yorder<FONT COLOR=black>,</FONT>
                     <FONT COLOR=blue>int</FONT> apertureSize <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>3<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvLaplace
//    Purpose:  Calculates Laplacian of the image: deltaI = d^2(I)/dx^2 + d^2(I)/dy^2.
//              Sobel operator is used for calculating derivatives.
//    Context:
//    Parameters:
//      src - source image
//      dst - destination image
//      apertureSize - size of applied aperture
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvLaplace<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT>
                       <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT>
                       <FONT COLOR=blue>int</FONT> apertureSize <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>3<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                    Morphology                                          *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvCreateStructuringElementEx
//    Purpose:
//      Allocates and fills IplConvKernel structure
//      which can be used as a structuring element in following morphological operations
//    Context:
//    Parameters:
//        cols   - number of columns in the kernel
//        rows   - number of rows in the kernel
//        anchorX - x-coordinate of anchor point(0..cols-1)
//        anchorY - y-coordinate of anchor point(0..rows-1)
//        shape   - shape of the structuring element
//              CV_SHAPE_RECT - rectangular element
//              CV_SHAPE_CROSS - cross-shaped element
//              CV_SHAPE_ELLIPSE - elliptic element
//              CV_SHAPE_CUSTOM - arbitrary element.
//              <values> array determines mask
//        values  - mask array. non-zero pixels determine shape of the element
//    Returns:
//        structuring element
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>IplConvKernel</FONT><FONT COLOR=black>*</FONT>  cvCreateStructuringElementEx<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>  cols<FONT COLOR=black>,</FONT>    <FONT COLOR=blue>int</FONT> rows<FONT COLOR=black>,</FONT>
                                                      <FONT COLOR=blue>int</FONT>  anchorX<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> anchorY<FONT COLOR=black>,</FONT>
                                                      CvElementShape shape<FONT COLOR=black>,</FONT>
                                                      <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> values <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvReleaseStructuringElement
//    Purpose:
//      Releases structuring element and clears pointer
//    Context:
//    Parameters:
//        element - double pointer to structuring element
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvReleaseStructuringElement<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplConvKernel</FONT><FONT COLOR=black>**</FONT> element <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvErode
//    Purpose:
//      Applies minimum filter to the source image given a structuring element
//    Context:
//    Parameters:
//        src    - source image
//        dst    - destination image, may be the same as source one.
//        element - structuring element.
//                  If the pointer is 0, 3x3 rectangular element is used.
//        iterations - how many times the erosion needs to be applied
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvErode<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT>
                       <FONT COLOR=darkmagenta>IplConvKernel</FONT><FONT COLOR=black>*</FONT> element <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                       <FONT COLOR=blue>int</FONT> iterations <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvDilate
//    Purpose:
//      Applies maximum filter to the source image given a structuring element
//    Context:
//    Parameters:
//        src    - source image
//        dst    - destination image, may be the same as source one.
//        element - structuring element.
//                  If the pointer is 0, 3x3 rectangular element is used.
//        iterations - how many times the dilation needs to be applied
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvDilate<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT>
                        <FONT COLOR=darkmagenta>IplConvKernel</FONT><FONT COLOR=black>*</FONT> element <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                        <FONT COLOR=blue>int</FONT> iterations <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvMorphologyEx
//    Purpose:
//      Applies one of the extended morphological operations, which based on
//      erosion and dilatation
//    Context:
//    Parameters:
//        src    - source image
//        dst    - destination image, may be the same as source one.
//        temp   - temporary image. The parameter must be non-zero
//                 if operation is CV_MOP_TOPHAT or CV_MOP_BLACKHAT and src == dst, or
//                 if operation is CV_MOP_GRADIENT
//        element - structuring element.
//                  If the pointer is 0, 3x3 rectangular element is used.
//        operation - one of the following:
//               (let's nB = "<element>, applied <iterations> times")
//                CV_MOP_OPEN:   dst = dilate(erode(src,nB),nB);
//                CV_MOP_CLOSE:  dst = erode(dilate(src,nB),nB);
//                CV_MOP_GRADIENT: dst = dilate(src,nB)-erode(src,nB)
//                CV_MOP_TOPHAT:   dst = src - erode(src,nB)
//                CV_MOP_BLACKHAT: dst = dilate(src,nB) - src
//        iterations - how many times the erosion/dilation needs to be applied
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMorphologyEx<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT>
                              <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> temp<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplConvKernel</FONT><FONT COLOR=black>*</FONT> element<FONT COLOR=black>,</FONT>
                              CvMorphOp operation<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> iterations <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                  Image Statistics                                      *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*      Image statistics functions support the next image formats:                        *
*         single-channel: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_32F                      *
*         three-channel: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_32F (COI must be != 0)    *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvSumPixels
//    Purpose:
//      Sums all the pixels in the image ROI
//    Context:
//    Parameters:
//        img - input image.
//    Returns:
//        sum of pixels in the ROI
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvSumPixels<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvCountNonZero
//    Purpose:
//      Counts all the non-zero pixels in the image ROI
//    Context:
//    Parameters:
//        img - input image.
//    Returns:
//        count of non-zero pixels
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>  cvCountNonZero<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvMean
//    Purpose:
//      Calculates average pixel value of image region
//    Context:
//    Parameters:
//        img - input image.
//        mask - byte-depth, single channel image, non-zero pixels of which
//               determine processes region
//    Returns:
//        average value
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvMean<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>
<FONT COLOR=darkblue>#define cvMeanMask cvMean</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvMean_StdDev
//    Purpose:
//      Calculates mean and standard deviation of pixels in the image region
//    Context:
//    Parameters:
//        img - input image.
//        mean - mean value
//        std_dev - standard deviation
//        mask - mask(byte-depth, single channel)
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>    cvMean_StdDev<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT><FONT COLOR=black>*</FONT> mean<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT><FONT COLOR=black>*</FONT> std_dev<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>
<FONT COLOR=darkblue>#define cvMean_StdDevMask(img, mask, mean, std_dev) cvMean_StdDev(img, mean, std_dev, mask)</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvMinMaxLoc
//    Purpose:
//      Finds minimum and maximum pixel values in the image region
//      and determines their locations.
//    Context:
//    Parameters:
//        img - input image.
//        minVal - minimum value
//        maxVal - maximum value
//        minLoc - location of the minimum
//        maxLoc - location of the maximum
//        mask - mask(byte-depth, single channel)
//    Returns:
//    Note:
//      If there are several global minimums and/or maximums,
//      function returns the most top-left extremums.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMinMaxLoc<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT><FONT COLOR=black>*</FONT> min_val<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT><FONT COLOR=black>*</FONT> max_val<FONT COLOR=black>,</FONT>
                           <FONT COLOR=darkmagenta>CvPoint</FONT><FONT COLOR=black>*</FONT> min_loc <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                           <FONT COLOR=darkmagenta>CvPoint</FONT><FONT COLOR=black>*</FONT> max_loc <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                           <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>
<FONT COLOR=darkblue>#define cvMinMaxLocMask(img, mask, min_val, max_val, min_loc, max_loc) \</FONT>
        cvMinMaxLoc<FONT COLOR=black>(</FONT>img<FONT COLOR=black>,</FONT> min_val<FONT COLOR=black>,</FONT> max_val<FONT COLOR=black>,</FONT> min_loc<FONT COLOR=black>,</FONT> max_loc<FONT COLOR=black>,</FONT> mask<FONT COLOR=black>)</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvMoments
//    Purpose:
//      Calculates moments(up to third order) of the image ROI.
//      It fills moments state and after that, it is possible to
//      return concrete moments using
//        cvGetSpatialMoment, cvGetCentralMoment or
//        cvGetNormalizedCentralMoment
//    Context:
//    Parameters:
//        img - input image
//        moments - output moments state.
//        binary - if non zero, function treats non-zero pixels as 1s.
//    Returns:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvMoments<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMoments</FONT><FONT COLOR=black>*</FONT> moments<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> binary <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT> 0 <FONT COLOR=black>));</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvGetSpatialMoment, cvGetCentralMoment, cvGetCentralNormalizedMoment
//    Purpose:
//      Returns different moments(up to third order) from moments state.
//        for raster image, these moments are defined as:
//        mij = spatial_moment(i,j) = sum(y=0,H-1) sum(x=0,W-1) [I(x,y) *(x^i) *(y^j)]
//       (where I(x,y) means pixel value at point(x,y). x^y means x power y).
//
//        muij = central_moment(i,j) = sum(y=0,H-1) sum(x=0,W-1)
//                                     [I(x,y) *(x-mean_x)^i) *((y-mean_y)^j)]
//       (where mean_x = m10/m00, mean_y = m01/m00.
//         it's easy to see that mu00 = m00, mu10 = mu01 = 0)
//
//        nu_ij = central_normalized_moment(i,j) = muij/(m00^((i+j)/2+1))
//    Context:
//    Parameters:
//        moments - moment state( filled by cvMoments or cvContourMoments )
//        x_order - x order of the moment
//        y_order - y order of the moment.
//        The following condition has to be satifsied:
//          0 <= x_order + y_order <= 3
//    Returns:
//        Required moment
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvGetSpatialMoment<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMoments</FONT><FONT COLOR=black>*</FONT> moments<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> x_order<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> y_order <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvGetCentralMoment<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMoments</FONT><FONT COLOR=black>*</FONT> moments<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> x_order<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> y_order <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvGetNormalizedCentralMoment<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMoments</FONT><FONT COLOR=black>*</FONT> moments<FONT COLOR=black>,</FONT>
                                              <FONT COLOR=blue>int</FONT> x_order<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> y_order <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvGetHuMoments
//    Purpose:
//      Calculates seven Hu invariants from normalized moments of second and third order
//    Context:
//    Parameters:
//        moments - moments state.
//        hu_moments - Hu moments
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>    cvGetHuMoments<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMoments</FONT><FONT COLOR=black>*</FONT>  moments<FONT COLOR=black>,</FONT> CvHuMoments<FONT COLOR=black>*</FONT>  hu_moments <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvNorm, cvNormMask
//    Purpose:
//      Calculates different types of norm for single or a pair of images
//    Context:
//    Parameters:
//        imgA - first input image
//        imgB - second input image
//        mask - determine pixels that are considered in norm calculation
//        norm_type - type of the norm.
//                                imgB == 0           imgB != 0
//         ---------------------------------------------------------------------------
//          CV_C:               ||imgA||_inf      ||imgA - imgB||_inf
//          CV_L1:              ||imgA||_L1       ||imgA - imgB||_L1
//          CV_L2:              ||imgA||_L2       ||imgA - imgB||_L2
//         ---------------------------------------------------------------------------
//          CV_RELATIVE_C:       forbidden       ||imgA - imgB||_inf/||imgB||_inf
//          CV_RELATIVE_L1:      forbidden       ||imgA - imgB||_L1/||imgB||_L1
//          CV_RELATIVE_L2:      forbidden       ||imgA - imgB||_L2/||imgB||_L2
//    Returns:
//      required norm
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvNorm<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> imgA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> imgB<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> norm_type<FONT COLOR=black>,</FONT>
                         <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>
<FONT COLOR=darkblue>#define cvNormMask(imgA, imgB, mask, norm_type) cvNorm(imgA, imgB, norm_type, mask)</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                     Drawing                                            *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*       Drawing functions work with the following formats:                               *
*           single channel: IPL_DEPTH_8U, IPL_DEPTH_8S                                   *
*           three channels: IPL_DEPTH_8U, IPL_DEPTH_8S, coi must be == 0                 *
*       All the functions include parameter color that means rgb value for three-channel *
*       images(and may be constructed with CV_RGB macro) and brightness                 *
*      (least-significant byte of color) for grayscale images.                          *
*       If drawn figure is partially or completely outside the image, it is clipped.     *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvLine
//    Purpose:
//      Draws line on the image ROI between two points
//    Context:
//    Parameters:
//        img  - image where the line is drawn.
//        pt1  - starting point
//        pt2  - ending point
//        thickness - line thickness. 1 means simple line.
//                    if line is thick, function draws the line with round endings.
//        color - line color(or brightness)
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvLine<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> pt1<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> pt2<FONT COLOR=black>,</FONT>
                      <FONT COLOR=blue>int</FONT> color<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> thickness <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvLineAA
//    Purpose:
//      Draws thin antialiazed line on the image ROI between two points
//    Context:
//    Parameters:
//        img  - image where the line is drawn.
//        pt1  - starting point
//        pt2  - ending point
//        scale - number of fractional bits in point coordinates.
//                That is, line can be drawn with sub-pixel accuracy
//        color - line color(or brightness)
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvLineAA<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> pt1<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> pt2<FONT COLOR=black>,</FONT>
                        <FONT COLOR=blue>int</FONT> color<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> scale <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvRectangle
//    Purpose:
//      Draws rectangle on the image ROI
//    Context:
//    Parameters:
//        img  - image where the rectangle is drawn.
//        pt1  - one of the rectangle corners
//        pt2  - opposite corner of the rectangle
//        thickness - thickness of the lines that made up rectangle.
//        color - line color(or brightness)
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvRectangle<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> pt1<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> pt2<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>int</FONT> color<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> thickness <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvCircle
//    Purpose:
//      Draws circle on the image ROI
//    Context:
//    Parameters:
//        img  - image.
//        center - circle center
//        radius - circle radius(must be >= 0)
//        color - circle color(or brightness)
//        thickenss - thickness of drawn circle. <0 means filled circle.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCircle<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> center<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> radius<FONT COLOR=black>,</FONT>
                        <FONT COLOR=blue>int</FONT> color<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> thickness <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvCircleAA
//    Purpose:
//      Draws circle on the image ROI
//    Context:
//    Parameters:
//        img  - image.
//        center - circle center
//        radius - circle radius(must be >= 0)
//        color - circle color(or brightness)
//        scale - number of fractional bits in point coordinates.
//                That is, circle can be drawn with sub-pixel accuracy
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCircleAA<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> center<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> radius<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>int</FONT> color<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> scale <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvEllipse
//    Purpose:
//      Draws elliptic arc
//    Context:
//    Parameters:
//        img  - image.
//        center - ellipse center
//        axes - half axes of the ellipse
//        angle - ellipse angle
//        startAngle - starting angle of elliptic arc
//        endAngle - ending angle of elliptic arc
//        thickness - arc thickness
//        color - ellipse color(or brightness)
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvEllipse<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> center<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> axes<FONT COLOR=black>,</FONT>
                         <FONT COLOR=blue>double</FONT> angle<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> startAngle<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> endAngle<FONT COLOR=black>,</FONT>
                         <FONT COLOR=blue>int</FONT> color<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> thickness <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvEllipseAA
//    Purpose:
//      Draws antialiazed elliptic arc
//    Context:
//    Parameters:
//        img  - image.
//        center - ellipse center
//        axes - half axes of the ellipse
//        angle - ellipse angle
//        startAngle - starting angle of elliptic arc
//        endAngle - ending angle of elliptic arc
//        scale - number of fractioanl bits in center coordinates and axes sizes.
//        color - ellipse color(or brightness)
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvEllipseAA<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> center<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> axes<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>double</FONT> angle<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> startAngle<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>double</FONT> endAngle<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> color<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> scale <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvFillConvexPoly
//    Purpose:
//      Fills convex polygon
//    Context:
//    Parameters:
//        img  - image.
//        pts  - array of polygon vertices
//        ntps - number of vertices in the polygon
//        color - polygon color(or brightness)
//    Returns:
//    Notes:
//        fucntion automatically closes the contour -
//        adds edge between first and last vertices.
//        function doesn't check that input polygon is convex.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFillConvexPoly<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT><FONT COLOR=black>*</FONT> pts<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> npts<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> color <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvFillPoly
//    Purpose:
//      Fills arbitrary regions, bounded by several polygonal contours.
//    Context:
//    Parameters:
//        img  - image.
//        contours - number of contours
//        pts  - array of pointers to polygonal contours
//        ntps - array of vertices counters for the contours
//        color - polygons color(or brightness)
//    Returns:
//    Notes:
//        function automatically closes each polygonal contour.
//        If some contours are overlapped, they are added modulo 2.
//        That is, pixel is filled, if it belongs to odd number of polygonal contours.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFillPoly<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT><FONT COLOR=black>**</FONT> pts<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> npts<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> contours<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> color <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvPolyLine
//    Purpose:
//      Draws polygons outline with simple or thick lines.
//    Context:
//    Parameters:
//        img  - image.
//        contours - number of contours
//        pts  - array of pointers to polygonal contours
//        ntps - array of vertices counters for the contours
//        closed - if non-zero, function closes each contour.
//        thickness - line thickness
//        color - polygons color(or brightness)
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvPolyLine<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT><FONT COLOR=black>**</FONT> pts<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> npts<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> contours<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>int</FONT> closed<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> color<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> thickness <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvPolyLineAA
//    Purpose:
//      Draws polygons outline with antialiazes lines.
//    Context:
//    Parameters:
//        img  - image.
//        contours - number of contours
//        pts  - array of pointers to polygonal contours
//        ntps - array of vertices counters for the contours
//        closed - if non-zero, function closes each contour.
//        scale - number of fractioanl bits in vertex coordinates
//        color - polygons color(or brightness)
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvPolyLineAA<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT><FONT COLOR=black>**</FONT> pts<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> npts<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> contours<FONT COLOR=black>,</FONT>
                            <FONT COLOR=blue>int</FONT> closed<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> color<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> scale <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvInitFont
//    Purpose:
//      Initializes font to use it in following text rendering operations
//    Context:
//    Parameters:
//        font - pointer to initialized font structure.
//        font_face - font family. There is a single font,
//                    supported now - CV_FONT_VECTOR0.
//        hscale - multiplier for horizontal letter sizes.
//                 If 1 then the original size is used,
//                 if 2 - twice wider, if 0.5 - twice thinner etc.
//        vscale - multiplier for vertical letter sizes.
//                 If 1 then the original size is used,
//                 if 2 - twice longer, if 0.5 - twice shorter etc.
//        italic_scale - tangent of letter slope, 0 means no slope,
//                       1 - 45 degree slope
//        thickness - letter thickness
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvInitFont<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvFont</FONT><FONT COLOR=black>*</FONT> font<FONT COLOR=black>,</FONT> CvFontFace font_face<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>double</FONT> hscale<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> vscale<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>double</FONT> italic_scale <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                          <FONT COLOR=blue>int</FONT> thickness <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvPutText
//    Purpose:
//      Draws text string on the image with given font
//    Context:
//    Parameters:
//        img  - image.
//        text - text string
//        org  - left-bottom corner of output text string
//        font - text font
//        color - polygons color(or brightness)
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvPutText<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT> text<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> org<FONT COLOR=black>,</FONT>
                         <FONT COLOR=darkmagenta>CvFont</FONT><FONT COLOR=black>*</FONT> font<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> color <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvGetTextSize
//    Purpose:
//      Calculates bounding rectangle for given text string and font.
//    Context:
//    Parameters:
//        text - text string
//        font - font to draw the string with
//        text_size - output parameter. width and height of bounding box
//                   (not including part of the text below base line)
//        ymin - output parameter. negative value or zero - minus height of
//               text part below base line
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvGetTextSize<FONT COLOR=black>(</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT> text_string<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvFont</FONT><FONT COLOR=black>*</FONT> font<FONT COLOR=black>,</FONT>
                             <FONT COLOR=darkmagenta>CvSize</FONT><FONT COLOR=black>*</FONT> text_size<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> ymin <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                                       Utilities                                        *
\****************************************************************************************/</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvInitLineIterator
//    Purpose:
//      Initializes iterator that gets all the pixels, lying on the raster line between
//      two given points
//    Context:
//    Parameters:
//        img  - image.
//        pt1  - starting point
//        pt2  - ending point. Both points must be inside the image
//        lineIterator - pointer to initialized iterator state
//    Returns:
//        number of pixels between pt1 and pt2.
//        It is equal to max( abs(pt1.x - pt2.x), abs(pt1.y - pt2.y))
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>  cvInitLineIterator<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> pt1<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> pt2<FONT COLOR=black>,</FONT>
                                 CvLineIterator<FONT COLOR=black>*</FONT> lineIterator <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvSampleLine
//    Purpose:
//      Fetch all the pixel, lying on the raster line between two given points and
//      writes them to the buffer
//    Context:
//    Parameters:
//        img  - image.
//        pt1  - starting point
//        pt2  - ending point. Both points must be inside the image
//        buffer - pointer to destination buffer.
//    Returns:
//        number of pixels stored.
//        It is equal to max( abs(pt1.x - pt2.x), abs(pt1.y - pt2.y))
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>  cvSampleLine<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> pt1<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> pt2<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> buffer <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvGetRectSubPix
//    Purpose:
//      Retrieves rectangle from the image with sub-pixel accuracy
//    Context:
//    Parameters:
//        src  - source image.
//        dst  - destination image. ROI must have odd width and height
//        center - center point of the extracted rectangle.
//                 Size of extracted rectangle is equal to
//                 desination image ROI size.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvGetRectSubPix<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint2D32f</FONT> center <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvCvtPixToPlane
//    Purpose:
//      Splits source image into several separate planes
//    Context:
//    Parameters:
//        src  - source image. Must have 3 or 4 channels.
//        dst0, dst1, dst2, dst3  - destination images. Must have single channel.
//               if src has 3 channels, dst3 must be NULL.
//               if one of the destination images is not NULL,
//               the corresponding channel is extracted from source image.
//               Else, all 3 or 4 images must be non NULL and all the source image
//               channels are written to destination images.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCvtPixToPlane<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>dst0<FONT COLOR=black>,</FONT>
                                 <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>dst1<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>dst2<FONT COLOR=black>,</FONT>
                                 <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>dst3 <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvCvtPixToPlane
//    Purpose:
//      Composes destination image from separate single-channel images
//    Context:
//    Parameters:
//        src0, src1, src2, src3  - source images. Must have single channel.
//              if destination image has 3 channels, src3 must be NULL, else must be
//              non NULL. Other images must always be non NULL.
//        dst - destination image. Must have 3 or 4 channels.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCvtPlaneToPix<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>src0<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>src1<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>src2<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>src3<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>dst <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvConvertScale
//    Purpose:
//      Converts image from one depth to another with linear transform
//    Context:
//    Parameters:
//        src - source image.
//        dst - destination image.
//        scale - multiplier
//        shift - delta. That is, dst(x,y) = src(x,y)*scale + shift.
//    Returns:
//    Notes:
//        only float->uchar and uchar->float are supported by now.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvConvertScale<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>dst<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> scale <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>),</FONT>
                              <FONT COLOR=blue>double</FONT> shift <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>
<FONT COLOR=darkblue>#define cvCvtScale cvConvertScale</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvAbsDiff
//    Purpose:
//      Finds per-pixel absolute difference between two images
//    Context:
//    Parameters:
//        srcA - first source image.
//        srcB - second source image
//        dst  - destination image, May be equal to srcA or srcB
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvAbsDiff<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> srcA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> srcB<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvAbsDiffS
//    Purpose:
//      Finds per-pixel absolute difference between image and scalar value
//    Context:
//    Parameters:
//        src - source image.
//        dst - destination image, May be equal to srcA or srcB
//        value - scalar value to compare with
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvAbsDiffS<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> value <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name: cvMatchTemplate
//    Purpose:
//      measures similarity between template and overlapped windows in the source image
//      and fills the resultant image with the measurements.
//    Context:
//    Parameters:
//      img     - source image
//      templ   - template to find
//      result  - resultant image. its ROI must have size:
//                     (img_width - templ_width + 1, img_height - templ_height + 1)
//      method  - comparison method:
//---------------------------------------------------------------------------------------
//             CV_TM_SQDIFF:  res0(i,j)=sum(y=0,TH-1) sum(x=0,TW-1)[I(i+x,j+y)-T(x,y)]^2
//                    (where  TW - template width, TH - template height
//                          res0(i,j) - pixel value of result at location(i,j)
//                                     (zero-th method)
//                          Iij(x,y) - pixel value of source image at location(i+x,j+y)
//                                     Iij alone means window of source image
//                                     with top-left corner(i,j) and template size.
//                          T(x,y) - pixel value of template at location(x,y)
//                                   T alone means template.
//---------------------------------------------------------------------------------------
//             CV_TM_SQDIFF_NORMED:  res1(i,j) = res0(i,j)/
//                                             (l2_norm(Iij)*l2_norm(templ);
//                      where  l2_norm(A) = sqrt(
//                                     sum(y=0,A_height-1) sum(x=0,A_width-1) A(x,y)^2);
//---------------------------------------------------------------------------------------
//             CV_TM_CCORR:  res2(i,j)=sum(y=0,TH-1) sum(x=0,TW-1)[Iij(x,y)*T(x,y)]
//---------------------------------------------------------------------------------------
//             CV_TM_CCORR_NORMED:  res3(i,j) = res2(i,j)/[l2_norm(Iij)*l2_norm(templ)];
//---------------------------------------------------------------------------------------
//             CV_TM_CCOEFF:  res4(i,j)=sum(y=0,TH-1) sum(x=0,TW-1) [I'ij(x,y)*T'(x,y)]
//                   where A'(x,y) = A(x,y)-1/(A_width*A_height)*
//                                   sum(l=0,A_height-1) sum(k=0,A_width-1)A(k,l)
//---------------------------------------------------------------------------------------
//             CV_TM_CCOEFF_NORMED:
//                   res5(i,j)=res4(i,j)/[l2_norm(I'ij)*l2_norm(T')]
//---------------------------------------------------------------------------------------
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMatchTemplate<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> templ<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> result<FONT COLOR=black>,</FONT>
                                 CvTemplMatchMethod method <FONT COLOR=black>);</FONT>


OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFillImage<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> val <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvbFastArctan
//    Purpose:
//      Calculates arctangent for arrays of abscissas and ordinates
//    Context:
//    Parameters:
//        y - array of abscissas
//        x - array of ordinates
//        angle - array of results: array[i] = arctan(y[i]/x[i])
//        len - number of elements in arrays
//    Returns:
//    Notes:
//      The function takes into account signs of both argument, so it is similar
//      to atan2, but it returns angle in degrees(from 0 to 359.999 degrees)
//      Maximal error is ~0.1 degreee.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvbFastArctan<FONT COLOR=black>(</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> y<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> x<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> angle<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> len <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvbCartToPolar
//    Purpose:
//      Converts input arrays of abscissas and ordinates to polar form
//    Context:
//    Parameters:
//        y - array of abscissas
//        x - array of ordinates
//        magnitude - array of magnitudes: mag[i] = sqrt(y[i]*y[i] + x[i]*x[i])
//        angle - array of angles: array[i] = arctan(y[i]/x[i])
//        len - number of elements in arrays
//    Returns:
//    Notes:
//      The function calculates angle(similar to cvbFastArctan) and magnitude for
//      every 2D vector(x[i],y[i]). Both output arguments are optional. If some
//      output parameter is absent, corresponding part is not calculated
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvbCartToPolar<FONT COLOR=black>(</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> y<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> x<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> magnitude<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> angle<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> len <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvbSqrt
//    Purpose:
//      Calculates square root for array of floats
//    Context:
//    Parameters:
//        x - array of arguments
//        sqrt_x - array of results
//        len - number of elements in arrays
//    Returns:
//    Notes:
//      Elements of input array must be non-negative, else the result is not defined.
//      Maximal relative error is ~3e-7
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvbSqrt<FONT COLOR=black>(</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> x<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> sqrt_x<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> len <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvbInvSqrt
//    Purpose:
//      Calculates inverse square root for array of floats
//    Context:
//    Parameters:
//        x - array of arguments
//        sqrt_x - array of results
//        len - number of elements in arrays
//    Returns:
//    Notes:
//      Elements of input array must be positive, else the result is not defined.
//      Maximal relative error is ~2e-7
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvbInvSqrt<FONT COLOR=black>(</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> x<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> inv_sqrt_x<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> len <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvbReciprocal
//    Purpose:
//      Calculates inverse value(1/x) for array of floats
//    Context:
//    Parameters:
//        x - array of arguments
//        inv_x - array of results
//        len - number of elements in arrays
//    Returns:
//    Notes:
//      For zero elements result is 0.
//      Maximal relative error is <2e-7
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvbReciprocal<FONT COLOR=black>(</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> x<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> inv_x<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> len <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvbFastExp
//    Purpose:
//      Calculates fast exponent approximation for array of floats
//    Context:
//    Parameters:
//        x - array of arguments
//        exp_x - array of results
//        len - number of elements in arrays
//    Returns:
//    Notes:
//      Overflow is not handled yet. Underflow is handled.
//      Maximal relative error is ~7e-6
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvbFastExp<FONT COLOR=black>(</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> x<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT><FONT COLOR=black>*</FONT> exp_x<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> len <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvbFastLog
//    Purpose:
//      Calculates fast logarithm approximation for array of doubles
//    Context:
//    Parameters:
//        x - array of arguments
//        log_x - array of logarithms of absolute values of arguments
//        len - number of elements in arrays
//    Returns:
//    Notes:
//      Negative values are negated before logarithm is taken.
//      Logarithm of 0 gives large negative number(~700)
//      Maximal relative error is ~3e-7
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvbFastLog<FONT COLOR=black>(</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>double</FONT><FONT COLOR=black>*</FONT> x<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> log_x<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> len <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvRandInit
//    Purpose:
//      Initializes random number generator(RNG)
//    Context:
//    Parameters:
//      state - pointer to initialized RNG state
//      lower - lower bound of random values
//      upper - upper bound of random values.
//              Generated random numbers belong to range [lower,upper)
//      seed  - initializing 32-bit integer for RNG
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvRandInit<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvRandState</FONT><FONT COLOR=black>*</FONT> state<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> lower<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> upper<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> seed <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvRandSetRange
//    Purpose: sets range of generated random numbers without reinitializing RNG
//    Context:
//    Parameters:
//      state - pointer to state structure
//      lower - lower bound
//      upper - upper bound
//    Returns:
//      CV_OK or error code if:
//         state pointer is zero or
//         lower bound greater than upper bound.
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvRandSetRange<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvRandState</FONT><FONT COLOR=black>*</FONT> state<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> lower<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> upper <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvbRand
//    Purpose:
//      Fills array of floats with random numbers and updates RNG state
//    Context:
//    Parameters:
//      state - RNG state
//      dst   - destination floating-point array
//      len   - number of elements in the array.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvbRand<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvRandState</FONT><FONT COLOR=black>*</FONT> state<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> len <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//
//    Name:    cvRandNext
//    Purpose:
//      Updates RNG state and returns 32-bit random number
//    Context:
//    Parameters:
//      state - RNG state
//    Returns:
//      random number
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>unsigned</FONT>  cvRandNext<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvRandState</FONT><FONT COLOR=black>*</FONT> state <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                               Motion templates                                         *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*        All the motion template functions work only with single channel images.         *
*        Silhouette image must have depth IPL_DEPTH_8U or IPL_DEPTH_8S                   *
*        Motion history image must have depth IPL_DEPTH_32F,                             *
*        Gradient mask - IPL_DEPTH_8U or IPL_DEPTH_8S,                                   *
*        Motion orientation image - IPL_DEPTH_32F                                        *
*        Segmentation mask - IPL_DEPTH_32F                                               *
*        All the angles are in degrees, all the times are in milliseconds                *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvUpdateMotionHistory
//    Purpose: updates motion history image.
//    Context:
//    Parameters:
//        silhouette  - silhouette image
//        mhi         - motion history image
//        timestamp   - current system time
//        mhiDuration - maximal duration of motion track before it will be removed
//    Returns:
//    Notes:
//      Motion history image is changed by the following algorithm:
//         for every point(x,y) in the mhi do
//             if( silhouette(x,y) != 0 )
//             {
//                 mhi(x,y) = timestamp;
//             }
//             else if( mhi(x,y) < timestamp - mhi_duration )
//             {
//                 mhi(x,y) = 0;
//             }
//             // else mhi(x,y) remains unchanged
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>    cvUpdateMotionHistory<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> silhouette<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mhi<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=blue>double</FONT> timestamp<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> mhiDuration <FONT COLOR=black>);</FONT>
<FONT COLOR=darkblue>#define  cvUpdateMHIByTime  cvUpdateMotionHistory</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCalcMotionGradient
//    Purpose: calculates motion gradient and mask where it is valid
//    Context:
//    Parameters:
//       mhi         - motion history image
//       mask        -(output image) indicates where <orientation> data is valid
//       orientation -(output image) contains gradient orientation in degrees
//       aperture_size - size of the filters for x & y derivatives
//
//       maxTDelta   - gradient bounds.
//       minTDelta   _/
//    Returns:
//    Notes:
//      Function handles both top-left and bottom-left origins of orientation image
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>    cvCalcMotionGradient<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mhi<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> orientation<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> aperture_size<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=blue>double</FONT> maxTDelta<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> minTDelta <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCalcGlobalOrientation
//    Purpose: calculates general motion direction in the selected region.
//    Context:
//    Parameters:
//         orient       - orientation image
//         mask         - region mask
//         mhi          - motion history image
//         timestamp    - the last timestamp when mhi was updated
//         mhi_duration - maximal motion track duration.
//    Returns:
//      direction of selected region in degrees
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvCalcGlobalOrientation<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> orientation<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask<FONT COLOR=black>,</FONT>
                                         <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mhi<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> curr_mhi_timestamp<FONT COLOR=black>,</FONT>
                                         <FONT COLOR=blue>double</FONT> mhi_duration <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSegmentMotion
//    Purpose: splits motion history image into several regions that
//             move in different directions.
//    Context:
//    Parameters:
//        mhi        - motion history image
//        seg_mask   - segmentation mask image. It is marked with different values
//                    (1,2,3...) for every motion component
//        storage    - where to store motion components
//        components - sequence of connected component of motion.
//        timestamp  - the last timestamp when mhi was updated
//        seg_thresh - threshold, which is used to split motion components(regions)
//                     the bigger threshold, the coarse segmentation is.
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSegmentMotion<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mhi<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> seg_mask<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>**</FONT> components<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>double</FONT> timestamp<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> seg_thresh <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                               Background Differencing                                  *
\****************************************************************************************/</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvAcc<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> sum<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSquareAcc<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> sqSum<FONT COLOR=black>,</FONT>
                           <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMultiplyAcc<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> imgA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> imgB<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> acc<FONT COLOR=black>,</FONT>
                              <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvRunningAvg<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> imgY<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> imgU<FONT COLOR=black>,</FONT>
                            <FONT COLOR=blue>double</FONT> alpha<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkblue>#define cvAccMask cvAcc</FONT>
<FONT COLOR=darkblue>#define cvSquareAccMask cvSquareAcc</FONT>
<FONT COLOR=darkblue>#define cvMultiplyAccMask cvMultiplyAcc</FONT>
<FONT COLOR=darkblue>#define cvRunningAvgMask(imgY, imgU, mask, alpha) cvRunningAvg(imgY, imgU, alpha, mask)</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                              Dynamic data structures                                   *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCreateMemStorage
//    Purpose: creates memory storage
//    Context:
//    Parameters:
//         block_size - size of memory storage blocks.
//                      If 0, default size( Currently 64K) is set
//    Returns:
//      memory storage
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT>  cvCreateMemStorage<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> block_size <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>));</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCreateChildMemStorage
//    Purpose: creates child memory storage
//            (storage that borrows memory blocks from parent)
//    Context:
//    Parameters:
//         parent - parent memory storage
//    Returns:
//      memory storage
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT>  cvCreateChildMemStorage<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> parent <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvReleaseMemStorage
//    Purpose: releases memory storage.
//    Context:
//    Parameters:
//         storage - double pointer to memory storage
//    Returns:
//    Notes:
//      if memory storage is simple, all its blocks are released,
//      else(memory storage is child) all its blocks are returned to parent
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvReleaseMemStorage<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>**</FONT> storage <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvClearMemStorage
//    Purpose: clears memory storage.
//    Context:
//    Parameters:
//         storage - memory storage
//    Returns:
//    Notes:
//      if memory storage is is child, all its blocks are returned to parent,
//      else the top of the storage is reset
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvClearMemStorage<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSaveMemStoragePos
//    Purpose: saves current top of the storage.
//    Context:
//    Parameters:
//         storage - memory storage
//         pos - position structure
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSaveMemStoragePos<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT> CvMemStoragePos<FONT COLOR=black>*</FONT> pos <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvRestoreMemStoragePos
//    Purpose: restores top of the storage.
//    Context:
//    Parameters:
//         storage - memory storage
//         pos - position structure that was filled with cvSaveMemStoragePos
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvRestoreMemStoragePos<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT> CvMemStoragePos<FONT COLOR=black>*</FONT> pos <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCreateSeq
//    Purpose: creates sequence, located on the storage
//    Context:
//    Parameters:
//         seq_flags - flags of created sequence
//         header_size - size of sequence header. Must be non-less than sizeof(CvSeq)
//         elem_size - size of sequence elements
//         storage - memory storage
//    Returns:
//      created sequence
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT>  cvCreateSeq<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> seq_flags<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> header_size<FONT COLOR=black>,</FONT>
                             <FONT COLOR=blue>int</FONT> elem_size<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSetSeqBlockSize
//    Purpose: adjusts granularity of memory allocation for sequence
//    Context:
//    Parameters:
//         seq - sequence pointer
//         delta_elements - how many elements to allocate when there is no free space
//                          in the sequence.
//    Returns:
//    Notes:
//      If this function is not called after sequence is created,
//      delta_elements is set to ~1K/elem_size
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSetSeqBlockSize<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> delta_elements <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSeqPush
//    Purpose: adds element in the end of sequence
//    Context:
//    Parameters:
//         seq - sequence pointer
//         element - added element
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSeqPush<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> element <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSeqPushFront
//    Purpose: adds element in the beginning of sequence
//    Context:
//    Parameters:
//         seq     - sequence pointer
//         element - added element
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSeqPushFront<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> element <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSeqPop
//    Purpose: removes element from the end of sequence
//    Context:
//    Parameters:
//         seq     - sequence pointer
//         element - optional parameter. If pointer is not NULL,
//                   removed element is copied there.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSeqPop<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> element <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSeqPopFront
//    Purpose: removes element from the beginning of sequence
//    Context:
//    Parameters:
//         seq     - sequence pointer
//         element - optional parameter. If pointer is not NULL,
//                   removed element is copied there.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSeqPopFront<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> element <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSeqPushMulti
//    Purpose: adds several elements in the end of sequence
//    Context:
//    Parameters:
//         seq      - sequence pointer
//         count    - number of added elements
//         elements - array of added elements.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSeqPushMulti<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> elements<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> count <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSeqPopMulti
//    Purpose: removes several elements from the end of sequence
//    Context:
//    Parameters:
//         seq      - sequence pointer
//         count    - number of removed elements
//         elements - optional parameter. If not NULL, removed elements are copied there
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSeqPopMulti<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> elements<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> count <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSeqInsert
//    Purpose: inserts element in the middle of the sequence
//    Context:
//    Parameters:
//         sequence     - sequence pointer
//         before_index - index of element, before which the element is inserted
//         element      - inserted element
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSeqInsert<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> before_index<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> element <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSeqRemove
//    Purpose: removes element from the middle of the sequence
//    Context:
//    Parameters:
//         seq      - sequence pointer
//         index    - index of removed element
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSeqRemove<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> index <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvClearSeq
//    Purpose: clears sequence(removes all sequence elements)
//    Context:
//    Parameters:
//         seq - sequence pointer
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvClearSeq<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGetSeqElem
//    Purpose: finds sequence element by its index
//    Context:
//    Parameters:
//         seq - sequence pointer
//         index - element index
//         block - optional output parameter. Sequence block, containing found element
//    Returns:
//         pointer to found element or NULL.
//    Notes:
//         index == -1 means last sequence element, -2 - prelast element etc.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT>  cvGetSeqElem<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> index<FONT COLOR=black>,</FONT> CvSeqBlock<FONT COLOR=black>**</FONT> block <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSeqElemIdx
//    Purpose: calculates element index from its address
//    Context:
//    Parameters:
//         seq - sequence pointer
//         element - sequence element
//         block - optional output parameter. Sequence block, containing found element.
//    Returns:
//         index of sequence element
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>int</FONT>  cvSeqElemIdx<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> element<FONT COLOR=black>,</FONT> CvSeqBlock<FONT COLOR=black>**</FONT> block <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvStartAppendToSeq
//    Purpose: initializes writer state for further writing to sequence
//    Context:
//    Parameters:
//         seq - sequence pointer
//         writer - pointer to initialized writer state
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvStartAppendToSeq<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> CvSeqWriter<FONT COLOR=black>*</FONT> writer <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvStartWriteSeq
//    Purpose: creates new sequence and initializes writer for it
//    Context:
//    Parameters:
//         seq_flags - flags of created sequence
//         header_size - size of sequence header. Must be non-less than sizeof(CvSeq)
//         elem_size - size of sequence elements
//         storage - memory storage, where the sequence will be located
//         writer - pointer to initialized writer state
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvStartWriteSeq<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> seq_flags<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> header_size<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>int</FONT> elem_size<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT>
                               CvSeqWriter<FONT COLOR=black>*</FONT> writer <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvEndWriteSeq
//    Purpose: ends writing process and closes writer
//    Context:
//    Parameters:
//         writer - writer state
//    Returns:
//         written sequence
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT>  cvEndWriteSeq<FONT COLOR=black>(</FONT> CvSeqWriter<FONT COLOR=black>*</FONT> writer <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvFlushSeqWriter
//    Purpose: updates sequence headers, but don't close writer
//    Context:
//    Parameters:
//         writer - writer state
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvFlushSeqWriter<FONT COLOR=black>(</FONT> CvSeqWriter<FONT COLOR=black>*</FONT> writer <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvStartReadSeq
//    Purpose: initializes sequence reader
//    Context:
//    Parameters:
//         seq - sequence pointer
//         reader - pointer to initialized reader state
//         reverse - if not 0, function moves read position to the end of sequence
//    Returns:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvStartReadSeq<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> CvSeqReader<FONT COLOR=black>*</FONT> reader<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> reverse <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGetSeqReaderPos
//    Purpose: returns read position
//    Context:
//    Parameters:
//         reader - reader state
//    Returns:
//         read position
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>    cvGetSeqReaderPos<FONT COLOR=black>(</FONT> CvSeqReader<FONT COLOR=black>*</FONT> reader <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSetSeqReaderPos
//    Purpose: moves read position
//    Context:
//    Parameters:
//         index  - new read position
//         is_relative - if not 0, index is offset from current position
//                      (else it is absolute position). Position is changed cyclically
//         reader - reader state
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvSetSeqReaderPos<FONT COLOR=black>(</FONT> CvSeqReader<FONT COLOR=black>*</FONT> reader<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> index<FONT COLOR=black>,</FONT>
                                  <FONT COLOR=blue>int</FONT> is_relative <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>));</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCvtSeqToArray
//    Purpose: copies sequence to array
//    Context:
//    Parameters:
//         seq - source sequence
//         array - destination array. Must have capacity at least
//                 seq->total*seq->elem_siz bytes
//    Returns:
//         pointer to array.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT>  cvCvtSeqToArray<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> array<FONT COLOR=black>,</FONT>
                                CvSlice slice <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>CV_WHOLE_SEQ<FONT COLOR=black>(</FONT>seq<FONT COLOR=black>))</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvMakeSeqHeaderForArray
//    Purpose: wraps array with sequence(without copying data)
//    Context:
//    Parameters:
//         seq_flags - flags of sequence
//         header_size - size of sequence header. Must be non-less than sizeof(CvSeq)
//         elem_size - size of sequence elements
//         array - source array.
//         total - total number of elements in array
//         seq   - pointer to local structure CvSeq
//         block - pointer to local structure CvSeqBlock
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMakeSeqHeaderForArray<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> seq_type<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> header_size<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=blue>int</FONT> elem_size<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> array<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> total<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> CvSeqBlock<FONT COLOR=black>*</FONT> block <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/************ Internal sequence functions ************/</FONT>
OPENCVAPI  CvStatus   cvChangeSeqBlock<FONT COLOR=black>(</FONT> CvSeqReader<FONT COLOR=black>*</FONT> reader<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> direction <FONT COLOR=black>);</FONT>
OPENCVAPI  CvStatus   cvCreateSeqBlock<FONT COLOR=black>(</FONT> CvSeqWriter<FONT COLOR=black>*</FONT> writer <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCreateSet
//    Purpose: creates new set
//    Context:
//    Parameters:
//         set_flags - flags of set
//         header_size - size of set header. Must be non-less than sizeof(CvSet)
//         elem_size - size of set elements.
//                     Must be non-less than 8 bytes, divisible by 4.
//                     Least significant bit of first 4-byte field of set elements must
//                     be zero.
//         storage   - memory storage, where the set will be located
//    Returns:
//         created set
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvSet</FONT><FONT COLOR=black>*</FONT>   cvCreateSet<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> set_flags<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> header_size<FONT COLOR=black>,</FONT>
                              <FONT COLOR=blue>int</FONT> elem_size<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSetAdd
//    Purpose: adds new element to the set
//    Context:
//    Parameters:
//         set - set
//         element - optional input parameter. If non NULL, it is copied to inserted
//                   element(starting from second 4-byte field)
//         inserted_element - optional output parameter. If non NULL, address of inserted
//                   element is stored there
//    Returns:
//         index of added element
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>   cvSetAdd<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSet</FONT><FONT COLOR=black>*</FONT> set<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSetElem</FONT><FONT COLOR=black>*</FONT> element <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                        <FONT COLOR=darkmagenta>CvSetElem</FONT><FONT COLOR=black>**</FONT> inserted_element <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSetRemove
//    Purpose: removes element from the set
//    Context:
//    Parameters:
//         set - set
//         index - index of removed element
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvSetRemove<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSet</FONT><FONT COLOR=black>*</FONT> set<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> index <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGetSetElem
//    Purpose: finds set element by its index
//    Context:
//    Parameters:
//         set - set
//         index - element index
//    Returns:
//         pointer to element or 0 if index is out of range or element at this index
//         isn't in the set
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvSetElem</FONT><FONT COLOR=black>*</FONT>  cvGetSetElem<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSet</FONT><FONT COLOR=black>*</FONT> set<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> index <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvClearSet
//    Purpose: clear set(removes all elements from the set)
//    Context:
//    Parameters:
//         set - set
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvClearSet<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSet</FONT><FONT COLOR=black>*</FONT> set <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCreateGraph
//    Purpose: creates graph
//    Context:
//    Parameters:
//         graph_flags - flags of created graph. CV_SEQ_KIND_GRAPH must be set,
//                       CV_GRAPH_FLAG_ORIENTED(if set) means oriented graph.
//         header_size - size of graph header. Must be non-less than sizeof(CvGraph)
//         vtx_size - size of graph vertices. Must be GREATER than sizeof(CvGraphVtx).
//                   (for example, sizeof(CvGraphVtx2D) can be used
//                     for simple graphs on the plane)
//         edge_size - size of graph edges. Must be non-less than sizeof(CvGraphEdge)
//         storage   - memory storage, where the graph will be located
//    Returns:
//         created graph
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT>   cvCreateGraph<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> graph_flags<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> header_size<FONT COLOR=black>,</FONT>
                                  <FONT COLOR=blue>int</FONT> vtx_size<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> edge_size<FONT COLOR=black>,</FONT>
                                  <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGraphAddVtx
//    Purpose: adds vertex to graph
//    Context:
//    Parameters:
//         graph - graph
//         vertex - optional input parameter. If pointer to vertex is not NULL,
//                  it is copied to inserted vertex
//                 (first sizeof(CvGraphVtx) bytes aren't copied)
//         inserted_vertex - optional output parameter. If not NULL, pointer to inserted
//                  vertex is stored there
//    Returns:
//         index of inserted vertex
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>   cvGraphAddVtx<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvGraphVtx</FONT><FONT COLOR=black>*</FONT> vertex <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                             <FONT COLOR=darkmagenta>CvGraphVtx</FONT><FONT COLOR=black>**</FONT> inserted_vertex <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGraphRemoveVtx, cvGraphRemoveVtxByPtr
//    Purpose: removes vertex from the graph
//    Context:
//    Parameters:
//         graph - graph
//         index - index of removed vertex
//         vtx - pointer to removed vertex
//    Returns:
//    Notes:
//      Vertex is removed with all the incident edges
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvGraphRemoveVtx<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> index <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvGraphRemoveVtxByPtr<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvGraphVtx</FONT><FONT COLOR=black>*</FONT> vtx <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGraphAddEdge, cvGraphAddEdgeByPtr
//    Purpose: add edge to graph
//    Context:
//    Parameters:
//         graph - graph
//         start_idx, end_idx - indices of starting and ending vertices
//         start_vtx, end_vtx - pointers to starting and ending vertices
//         edge - optional input parameter. If not NULL, the edge is copied to
//                inserted edge(first sizeof(CvGraphEdge) bytes aren't copied
//         inserted_edge - optional output parameter. Points to inserted edge.
//    Returns:
//    Notes:
//       starting vertex must differ from ending one.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvGraphAddEdge<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>int</FONT> start_idx<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> end_idx<FONT COLOR=black>,</FONT>
                               <FONT COLOR=darkmagenta>CvGraphEdge</FONT><FONT COLOR=black>*</FONT> edge <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                               <FONT COLOR=darkmagenta>CvGraphEdge</FONT><FONT COLOR=black>**</FONT> inserted_edge <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvGraphAddEdgeByPtr<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph<FONT COLOR=black>,</FONT>
                               <FONT COLOR=darkmagenta>CvGraphVtx</FONT><FONT COLOR=black>*</FONT> start_vtx<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvGraphVtx</FONT><FONT COLOR=black>*</FONT> end_vtx<FONT COLOR=black>,</FONT>
                               <FONT COLOR=darkmagenta>CvGraphEdge</FONT><FONT COLOR=black>*</FONT> edge <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                               <FONT COLOR=darkmagenta>CvGraphEdge</FONT><FONT COLOR=black>**</FONT> inserted_edge <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGraphRemoveEdge, cvGraphRemoveEdgeByPtr
//    Purpose: removes edge to graph
//    Context:
//    Parameters:
//         graph - graph
//         start_idx, end_idx - indices of starting and ending vertices
//         start_vtx, end_vtx - pointers to starting and ending vertices
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvGraphRemoveEdge<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> start_idx<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> end_idx <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvGraphRemoveEdgeByPtr<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvGraphVtx</FONT><FONT COLOR=black>*</FONT> start_vtx<FONT COLOR=black>,</FONT>
                                         <FONT COLOR=darkmagenta>CvGraphVtx</FONT><FONT COLOR=black>*</FONT> end_vtx <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvFindGraphEdge, cvFindGraphEdgeByPtr
//    Purpose: finds edge, connecting two vertices. If graph is orientation, order
//             of input vertices is taken into account
//    Context:
//    Parameters:
//         graph - graph
//         start_idx, end_idx - indices of starting and ending vertices
//         start_vtx, end_vtx - pointers to starting and ending vertices
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvGraphEdge</FONT><FONT COLOR=black>*</FONT>  cvFindGraphEdge<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> start_idx<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> end_idx <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvGraphEdge</FONT><FONT COLOR=black>*</FONT>  cvFindGraphEdgeByPtr<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvGraphVtx</FONT><FONT COLOR=black>*</FONT> start_vtx<FONT COLOR=black>,</FONT>
                                              <FONT COLOR=darkmagenta>CvGraphVtx</FONT><FONT COLOR=black>*</FONT> end_vtx <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvClearGraph
//    Purpose: clear graph(removes all the edges and vertices from the graph)
//    Context:
//    Parameters:
//         graph - graph
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvClearGraph<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGraphVtxDegree, cvGraphVtxDegreeByPtr
//    Purpose: counts edges, incident to given vertex
//    Context:
//    Parameters:
//         graph - graph
//         vtx_idx - vertex index
//         vtx - pointer to vertex
//    Returns:
//      number of incident edges
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>  cvGraphVtxDegree<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> vtx_idx <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>  cvGraphVtxDegreeByPtr<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvGraph</FONT><FONT COLOR=black>*</FONT> graph<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvGraphVtx</FONT><FONT COLOR=black>*</FONT> vtx <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGetGraphVtx
//    Purpose: finds graph vertex by its index
//    Context:
//    Parameters:
//         graph - graph
//         idx - vertex index
//    Returns:
//      pointer to vertex
//F*/</FONT>
<FONT COLOR=darkblue>#define cvGetGraphVtx( graph, idx ) (CvGraphVtx*)cvGetSetElem((CvSet*)(graph), (idx))</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGraphVtxIdx
//    Purpose: calculates index of the graph vertex
//    Context:
//    Parameters:
//         graph - graph
//         vtx - pointer to vertex
//    Returns:
//      vertex index
//F*/</FONT>
<FONT COLOR=darkblue>#define cvGraphVtxIdx( graph, vtx ) cvSeqElemIdx((CvSeq*)(graph),(vtx),0)</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGraphEdgeIdx
//    Purpose: calculates index of the graph edge
//    Context:
//    Parameters:
//         graph - graph
//         edge - pointer to graph edge
//    Returns:
//      edge index
//F*/</FONT>
<FONT COLOR=darkblue>#define cvGraphEdgeIdx( graph, edge ) cvSeqElemIdx((CvSeq*)((graph)-&gt;edges),(edge),0)</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                              Planar subdivisions                                       *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCreateSubdiv2D
//    Purpose: creates initially empty planar subdivision structure
//    Context:
//    Parameters:
//      subdiv_type - type of subdivision
//      header_size - size of header(>= sizeof(CvSubdiv2D))
//      quadedge_size - size of quad-edges(>= sizeof(CvQuadEdge2D))
//      vtx_size - size of vertices(>= sizeof(CvSubdiv2DPoint))
//      storage  - size of memory storage
//    Returns:
//      created subdivision
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvSubdiv2D</FONT><FONT COLOR=black>*</FONT>  cvCreateSubdiv2D<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> subdiv_type<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> header_size<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=blue>int</FONT> vtx_size<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> quadedge_size<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSubdiv2DMakeEdge
//    Purpose: creates new isolated quad-edge
//    Context:
//    Parameters:
//      subdiv - subdivision - owner of the quadedge
//    Returns:
//      first edge of quad-edge.
//F*/</FONT>
OPENCVAPI  CvSubdiv2DEdge  cvSubdiv2DMakeEdge<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSubdiv2D</FONT><FONT COLOR=black>*</FONT> subdiv <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSubdiv2DAddPoint
//    Purpose:  basic topological operation: breaks or combines edge rings
//    Context:
//    Parameters:
//      edgeA - first edge
//      edgeB - second edge
//F*/</FONT>
OPENCVAPI  CvSubdiv2DPoint<FONT COLOR=black>*</FONT>   cvSubdiv2DAddPoint<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSubdiv2D</FONT><FONT COLOR=black>*</FONT> subdiv<FONT COLOR=black>,</FONT>
                                               <FONT COLOR=darkmagenta>CvPoint2D32f</FONT> pt<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> is_virtual <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSubdiv2DSplice
//    Purpose:  basic topological operation: breaks or combines edge rings
//    Context:
//    Parameters:
//      edgeA - first edge
//      edgeB - second edge
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSubdiv2DSplice<FONT COLOR=black>(</FONT> CvSubdiv2DEdge  edgeA<FONT COLOR=black>,</FONT>  CvSubdiv2DEdge  edgeB <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSubdiv2DSetEdgePoints
//    Purpose:  assigns edge origin and desination points
//    Context:
//    Parameters:
//      edge - edge
//      org_pt - point to origin vertex
//      dst_pt - point to destination vertex
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSubdiv2DSetEdgePoints<FONT COLOR=black>(</FONT> CvSubdiv2DEdge edge<FONT COLOR=black>,</FONT>
                                       CvSubdiv2DPoint<FONT COLOR=black>*</FONT> org_pt<FONT COLOR=black>,</FONT>
                                       CvSubdiv2DPoint<FONT COLOR=black>*</FONT> dst_pt <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSubdiv2DDeleteEdge
//    Purpose:  deletes edge from subdivision.
//    Context:
//    Parameters:
//      subdiv - subdivison
//      edge - deleted edge
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSubdiv2DDeleteEdge<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSubdiv2D</FONT><FONT COLOR=black>*</FONT> subdiv<FONT COLOR=black>,</FONT> CvSubdiv2DEdge edge <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSubdiv2DConnectEdges
//    Purpose:  connect destination point of the first edge with
//              origin point of the second edge
//    Context:
//    Parameters:
//      subdiv - subdivison
//      edgeA - first edge
//      edgeB - second edge
//F*/</FONT>
OPENCVAPI  CvSubdiv2DEdge  cvSubdiv2DConnectEdges<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSubdiv2D</FONT><FONT COLOR=black>*</FONT> subdiv<FONT COLOR=black>,</FONT>
                                                CvSubdiv2DEdge edgeA<FONT COLOR=black>,</FONT>
                                                CvSubdiv2DEdge edgeB <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSubdiv2DSwapEdges
//    Purpose:  swap diagonal in two connected Delaunay facets
//    Context:
//    Parameters:
//      subdiv - subdivison
//      edge - sudivision edge
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSubdiv2DSwapEdges<FONT COLOR=black>(</FONT> CvSubdiv2DEdge edge <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSubdiv2DLocate
//    Purpose:  finds location of the point within the Delaunay triangulation
//              origin point of the second edge
//    Context:
//    Parameters:
//      subdiv - subdivison
//      pt     - searched point
//      _edge  - bounding edge for facet, containing the point
//      _point - vertex(if searched point coincides with the vertex)
//F*/</FONT>
OPENCVAPI  CvSubdiv2DPointLocation  cvSubdiv2DLocate<FONT COLOR=black>(</FONT>
                               <FONT COLOR=darkmagenta>CvSubdiv2D</FONT><FONT COLOR=black>*</FONT> subdiv<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint2D32f</FONT> pt<FONT COLOR=black>,</FONT>
                               CvSubdiv2DEdge <FONT COLOR=black>*</FONT>_edge<FONT COLOR=black>,</FONT>
                               CvSubdiv2DPoint<FONT COLOR=black>**</FONT> _point <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvInitSubdivDelaunay2D
//    Purpose:  connect destination point of the first edge with
//              origin point of the second edge
//    Context:
//    Parameters:
//      subdiv - subdivison
//      pt     - searched point
//      _edge  - bounding edge for facet, containing the point
//      _point - vertex(if searched point coincides with the vertex)
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvInitSubdivDelaunay2D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSubdiv2D</FONT><FONT COLOR=black>*</FONT> subdiv<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvRect</FONT> rect <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSubdivDelaunay2DInsert
//    Purpose:  insert the point into the triangulation
//    Context:
//    Parameters:
//      subdiv - subdivison
//      pt     - inserted point
//F*/</FONT>
OPENCVAPI  CvSubdiv2DPoint<FONT COLOR=black>*</FONT>  cvSubdivDelaunay2DInsert<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSubdiv2D</FONT><FONT COLOR=black>*</FONT> subdiv<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint2D32f</FONT> pt<FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCalcSubdivVoronoi2D
//    Purpose:  calculates Voronoi tesselation( Coordinates of Voronoi points)
//    Context:
//    Parameters:
//      subdiv - subdivison
//    Note:
//      Before calculations the function checks the flag, indicating that
//      the Voronoi tesselation is already calculated.
//      If subdivision is modified(some points have been inserted), the flag is cleared.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcSubdivVoronoi2D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSubdiv2D</FONT><FONT COLOR=black>*</FONT> subdiv <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvClearSubdivVoronoi2D
//    Purpose:  removes all Voronoi points from the tesselation.
//    Context:
//    Parameters:
//      subdiv - subdivison
//    Note:
//      The function is called implicitly from the cvCalcSubdivVoronoi2D
//      before Voronoi tesselation is calculated.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvClearSubdivVoronoi2D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSubdiv2D</FONT><FONT COLOR=black>*</FONT> subdiv <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                              Contours procceding                                       *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvFindContours
//    Purpose: finds contours on the binary image
//    Context:
//    Parameters:
//         img - binary image(depth is IPL_DEPTH_8U or IPL_DEPTH_8S, single channel).
//         storage - memory storage where the contours will be stored
//         firstContour - output parameter. First contour on the highest level.
//         headerSize - size of contours headers.
//         mode - contour retrieving mode.
//                  CV_RETR_EXTERNAL - get only the most external contours(list).
//                  CV_RETR_LIST     - get all the contours without any hierarchical links
//                                    (list).
//                  CV_RETR_CCOMP    - get all the contours and make holes as child
//                                     contours of corresponding external contour
//                                    (two-level hierarchical structure)
//                  CV_RETR_TREE     - get all the contours and build all
//                                     hierarchical links(tree).
//         method - approximation method
//                CV_CHAIN_CODE    - output contours in chain-coded form(Freeman code).
//                              The rest of methods approximate chain code with polyline
//                CV_CHAIN_APPROX_NONE - no compression. Every point of digital curve
//                                       is coded
//                CV_CHAIN_APPROX_SIMPLE - horizontal, vertical and diagonal segments are
//                                         are coded with ending vertices (by default).
//                CV_CHAIN_APPROX_TC89_L1 - Teh-Chin algorithm, L1 curvature
//                CV_CHAIN_APPROX_TC89_KCOS - Teh-Chin algorithm, k-cosine curvature
//    Returns:
//      Number of contours found.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>  cvFindContours<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT>
                           <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>**</FONT>  firstContour<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>int</FONT>  headerSize <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT><FONT COLOR=blue>sizeof</FONT><FONT COLOR=black>(</FONT>CvContour<FONT COLOR=black>)),</FONT>
                           CvContourRetrievalMode mode <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT> CV_RETR_LIST <FONT COLOR=black>),</FONT>
                           CvChainApproxMethod method <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>CV_CHAIN_APPROX_SIMPLE<FONT COLOR=black>));</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvStartFindContours
//    Purpose: starts iterrative process of contours retrieving
//    Context:
//    Parameters:
//         img - binary image(depth is IPL_DEPTH_8U or IPL_DEPTH_8S, single channel).
//         storage - memory storage where the contours will be stored
//         header_size - size of contours headers.
//         mode - contour retrieving mode(see cvFindContours description)
//         method - approximation method(see cvFindContours description)
//    Returns:
//      contour scanner state.
//F*/</FONT>
OPENCVAPI  CvContourScanner   cvStartFindContours<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT>
                                        <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> header_size<FONT COLOR=black>,</FONT>
                                        CvContourRetrievalMode mode<FONT COLOR=black>,</FONT>
                                        CvChainApproxMethod method <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvFindNextContour
//    Purpose: finds next contour on the image
//    Context:
//    Parameters:
//         scanner - contour scanner state
//    Returns:
//      next contour or NULL, if no more contours on the image
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT>  cvFindNextContour<FONT COLOR=black>(</FONT> CvContourScanner scanner <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvSubstituteContour
//    Purpose: substitutes retrived contour with another one.
//    Context:
//    Parameters:
//         scanner - contour scanner state
//         newContour - substituting contour
//                      (or NULL, if retrived contour should be rejected)
//    Returns:
//    Notes:
//      The function may be called immediately after contour is retrived
//     (may be, after some processing) before cvFindNextContour is called next time.
//      It replaces found contour with processed contour, or even rejects it.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvSubstituteContour<FONT COLOR=black>(</FONT> CvContourScanner scanner<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> newContour <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvEndFindContours
//    Purpose: finishes process of contours retrieving
//    Context:
//    Parameters:
//         scanner - contour scanner state
//    Returns:
//      pointer to first contour on the highest hierarchical level
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT>  cvEndFindContours<FONT COLOR=black>(</FONT> CvContourScanner<FONT COLOR=black>*</FONT> scanner <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvApproxChains
//    Purpose: approximates single(all) chains with polylines.
//    Context:
//    Parameters:
//         src_seq - pointer to chain(which can reffer to other chains).
//         storage - where to place resultant polylines.
//         dst_seq - double pointer to first resultant polyline.
//         method  - approximation method(see cvFindContours description)
//         parameter - method parameter(is not used now).
//         minimal_perimeter - approximates only those contours which perimeter is
//                             not less than <minimal_perimeter>. Other chains
//                             are removed from resultant structure
//         recursive - if not 0, approximate all the chains, which can be accessed
//                     from src_seq. if 0, approximate a single chain
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT>   cvApproxChains<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> src_seq<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT>
                                 CvChainApproxMethod method <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>CV_CHAIN_APPROX_SIMPLE<FONT COLOR=black>),</FONT>
                                 <FONT COLOR=blue>double</FONT> parameter <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                                 <FONT COLOR=blue>int</FONT>  minimal_perimeter <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                                 <FONT COLOR=blue>int</FONT>  recursive <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>));</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvStartReadChainPoints
//    Purpose: starts read successive points of the chain-coded curve
//    Context:
//    Parameters:
//         chain   - chain
//         reader  - chain reader state
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvStartReadChainPoints<FONT COLOR=black>(</FONT> CvChain<FONT COLOR=black>*</FONT> chain<FONT COLOR=black>,</FONT> CvChainPtReader<FONT COLOR=black>*</FONT> reader <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvReadChainPoint
//    Purpose: read current point of the chain and moves read position to the next code
//    Context:
//    Parameters:
//         reader - chain reader state
//    Returns:
//         current point of the chain
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvPoint</FONT>   cvReadChainPoint<FONT COLOR=black>(</FONT> CvChainPtReader<FONT COLOR=black>*</FONT> reader <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvApproxPoly
//    Purpose: approximates polygonal contour with another polygonal contour with desired
//             accuracy
//    Context:
//    Parameters:
//         src_seq - source contour
//         header_size - size of destination contour header
//         storage - memory storage for result
//         dst_seq - destination contour
//         method  - approximation method. Only a single method is implemented now.
//                      CV_POLY_APPROX_DP - Douglas-Peucker method.
//         parameter - depends on method. For CV_POLY_APPROX_DP it is a desired accuracy.
//         recursive - if not 0, the function approximates all the contours that
//                     are next to or below the initial contour, otherwise the single
//                     contour is approximated
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT>  cvApproxPoly<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> src_seq<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT>  header_size<FONT COLOR=black>,</FONT>
                              <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT>
                              CvPolyApproxMethod  method<FONT COLOR=black>,</FONT>
                              <FONT COLOR=blue>double</FONT>  parameter<FONT COLOR=black>,</FONT>
                              <FONT COLOR=blue>int</FONT> recursive <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>));</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvContourPerimeter
//    Purpose:
//      Calculates contour perimeter, finds minimal edge and maximal egde lengths
//    Context:
//    Parameters:
//      contour  - source contour
//      slice    - optional parameter. ending and starting indices of contour section  
//    Returns:
//      contour section perimeter
//      when a part of contour is selected, the function doesn't add
//      length of chord, connecting starting and ending points
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvContourPerimeter<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour<FONT COLOR=black>,</FONT>
                                    CvSlice slice <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>CV_WHOLE_SEQ<FONT COLOR=black>(</FONT>contour<FONT COLOR=black>))</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvContourBoundingRect
//    Purpose:
//      calculates contour bounding rebox
//    Context:
//    Parameters:
//      contour - pointer to the source contour
//    Returns:
//      bounding rectangle
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvRect</FONT>  cvContourBoundingRect<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> update <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvContourMoments
//    Purpose:
//      Calculates spatial and central moments of the contour up to order 3
//    Context:
//    Parameters:
//      contour - the source contour
//      moments - output parameter. Pointer to the calculated moments
//
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvContourMoments<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMoments</FONT><FONT COLOR=black>*</FONT> moments<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvContourArea
//    Purpose:
//      Calculates area within the contour
//    Context:
//    Parameters:
//      contour - pointer to input contour object.
//      slice  - optional parameter. ending and starting indices of contour section  
//    Returns:
//      Contour section area
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvContourArea<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour<FONT COLOR=black>,</FONT>
                               CvSlice slice <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>CV_WHOLE_SEQ<FONT COLOR=black>(</FONT>contour<FONT COLOR=black>)));</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvMatchContours
//    Purpose:
//      Compares two contours
//    Context:
//    Parameters:
//      contour1 - pointer to the first input contour object.
//      contour2 - pointer to the second input contour object.
//      method - method for the matching calculation
//     (now CV_CONTOURS_MATCH_I1, CV_CONTOURS_MATCH_I2 or
//      CV_CONTOURS_MATCH_I3 only  )
//      parameter - method-specific parameter (is used now)
//    Returns:
//      Comparison result
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvMatchContours<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour1<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour2<FONT COLOR=black>,</FONT>
                                 CvContoursMatchMethod method<FONT COLOR=black>,</FONT>
                                 <FONT COLOR=blue>long</FONT> parameter <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>));</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvCreateContourTree
//    Purpose:
//      Creates binary tree representation for the contour
//    Context:
//    Parameters:
//      contour - input contour
//      storage - storage
//      tree    - output pointer to the binary tree representation
//      threshold - threshold for the binary tree building
//    Returns:
//      Binary tree
//F*/</FONT>
OPENCVAPI  CvContourTree<FONT COLOR=black>*</FONT>   cvCreateContourTree<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT>
                                              <FONT COLOR=blue>double</FONT> threshold <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvContourFromContourTree
//    Purpose:
//      Reconstructs contour from binary tree representation
//    Context:
//    Parameters:
//      tree   -  input binary tree representation
//      storage - memory storage
//      criteria - criteria for the definition threshold value
//                 for the contour reconstruction(level or precision)
//    Returns:
//      Created contour
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT>  cvContourFromContourTree<FONT COLOR=black>(</FONT> CvContourTree <FONT COLOR=black>*</FONT>tree<FONT COLOR=black>,</FONT>
                                          <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT>
                                          <FONT COLOR=darkmagenta>CvTermCriteria</FONT> criteria <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvMatchContourTrees
//    Purpose:
//      Compares two contour trees
//    Context:
//    Parameters:
//      tree1 - pointer to the first input contour tree object.
//      tree2 - pointer to the second input contour tree object.
//      method - method for the matching calculation
//     (now CV_CONTOUR_TREES_MATCH_I1 only  )
//      threshold - threshold for the contour trees matching
//    Returns:
//      comparison result
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvMatchContourTrees<FONT COLOR=black>(</FONT> CvContourTree <FONT COLOR=black>*</FONT>tree1<FONT COLOR=black>,</FONT>
                                     CvContourTree <FONT COLOR=black>*</FONT>tree2<FONT COLOR=black>,</FONT>
                                     CvContourTreesMatchMethod method<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>double</FONT> threshold <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvDrawContours
//    Purpose:
//      Draws one or more contours outlines or their interiors on the image
//    Context:
//    Parameters:
//      img      - destination three-channel image
//      contour  - pointer to drawn contour(s).
//      external_color - color to draw external contours with
//      hole_color - color to draw hole contours with
//      max_level  - max level of the tree(starting from contour pointer) to draw.
//                   if it is 0, draw single contour, if 1 - draw the contour and
//                   other contours at the same level, 2 - draw two levels etc.
//      thickness - thickness of lines the contours are drawn with. If it is
//                  equal to CV_FILLED (-1), the contour(s) interior is filled.
//    Returns:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvDrawContours<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour<FONT COLOR=black>,</FONT>
                             <FONT COLOR=blue>int</FONT> external_color<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> hole_color<FONT COLOR=black>,</FONT>
                             <FONT COLOR=blue>int</FONT> max_level<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> thickness <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvCalcPGH
//    Purpose:
//      Calculates PGH(pairwise geometric histogram) for given contour.
//    Context:
//    Parameters:
//      contour  - input contour.
//      pgh      - output histogram(must be two-dimensional)
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcPGH<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                          Computational Geometry functions                              *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvConvexHull
//    Purpose:
//      Finds convex hull of points set
//    Context:
//    Parameters:
//      points       - array of points
//      num_points   - number of input points
//      bound_rect   - pointer to bounding rectangle(if computed), can be NULL
//      orientation  - orientation of convex hull you want to get
//                     can be CV_CLOCKWISE or CV_COUNTER_CLOCKWISE
//      hull         - pointer to output array
//      hullsize     - pointer to output value, which is number of convex hull vertices
//
//    Returns:
//    Notes: Function computes convex hull and stores result in "hull" array,
//           where every vertex of convex hull is represented by index in input array.
//
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvConvexHull<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT><FONT COLOR=black>*</FONT> points<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> num_points<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvRect</FONT><FONT COLOR=black>*</FONT> bound_rect<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>int</FONT> orientation<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> hull<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> hullsize <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvContourConvexHull
//    Purpose:
//      Finds convex hull of contour
//    Context:
//    Parameters:
//      contour      - pointer to CvSeq structure, which elements are CvPoints
//      orientation  - orientation of convex hull you want to get
//                     can be CV_CLOCKWISE or CV_COUNTER_CLOCKWISE
//      storage      - pointer to memory storage, where output sequence will be stored
//    Returns:
//      Convex hull
//    Notes: Function computes convex hull and returns it.
//           Every vertex of convex hull is represented by pointer to original point,
//           stored in input sequence, i.e. result is CvSeq which elements
//           have type CvPoint*
//F*/</FONT>
OPENCVAPI <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT>  cvContourConvexHull<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> orientation<FONT COLOR=black>,</FONT>
                                    <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvConvexHullApprox
//    Purpose:
//      Finds approximate convex hull of points set
//    Context:
//    Parameters:
//      points       - array of points
//      num_points   - number of input points
//      bound_rect   - pointer to bounding rectangle(if computed), can be NULL
//      bandwidth    - width of band, used in algorithm
//      orientation  - orientation of convex hull you want to get
//                     can be CV_CLOCKWISE or CV_COUNTER_CLOCKWISE
//      hullpoints   - pointer to output array
//      hullsize     - pointer to output value, which is number of convex hull vertices
//
//    Returns:
//    Notes: Function computes approximate convex hull and stores result in "hull" array,
//           where every vertex of convex hull is represented by index in input array.
//           If bandwidth == 1, then exact convex hull is computed.
//
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvConvexHullApprox<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT><FONT COLOR=black>*</FONT> points<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> num_points<FONT COLOR=black>,</FONT>
                                  <FONT COLOR=darkmagenta>CvRect</FONT><FONT COLOR=black>*</FONT> bound_rect<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> bandwidth<FONT COLOR=black>,</FONT>
                                  <FONT COLOR=blue>int</FONT> orientation<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> hullpoints<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> hullsize <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvContourConvexHullApprox
//    Purpose:
//      Finds approximate convex hull of contour
//    Context:
//    Parameters:
//      contour      - pointer to CvSeq structure, which elements are CvPoints
//      bandwidth    - width of band, used in algorithm
//      orientation  - orientation of convex hull you want to get
//                     can be CV_CLOCKWISE or CV_COUNTER_CLOCKWISE
//      storage      - pointer to memory storage, where output sequence will be stored
//    Returns:
//    Notes: Function computes approximate convex hull and returns it.
//           Every vertex of convex hull is represented by pointer to original point,
//           stored in input sequence, i.e. result is CvSeq which elements
//           have type CvPoint*
//F*/</FONT>
OPENCVAPI <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT>  cvContourConvexHullApprox<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> bandwidth<FONT COLOR=black>,</FONT>
                                          <FONT COLOR=blue>int</FONT> orientation<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvCheckContourConvexity
//    Purpose:
//      Checks if contour is convex or not
//    Context:
//    Parameters:
//      contour - input contour
//
//    Returns: 0 - contour is not convex
//             1 - contour is convex
//    Notes:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>int</FONT>  cvCheckContourConvexity<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvConvexityDefects
//    Purpose:
//      Computes convexity defects of contour
//    Context:
//    Parameters:
//      contour      - pointer to CvSeq structure, which elements are CvPoints
//      convexhull   - pointer to convex hull of input contour
//      storage      - pointer to memory storage, where output sequence will be stored
//    Returns:
//      sequence of convexity defects.
//    Notes:
//F*/</FONT>
OPENCVAPI <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT>  cvConvexityDefects<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> contour<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> convexhull<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvFitEllipse
//    Purpose:
//      Fits "least-square optimal" ellipse into the set of points
//    Context:
//    Parameters:
//      points       - array of 2D points with float coordinates
//      n            - number of input points
//      box          - output structure which contents center of ellipse
//                     full sizes of ellipse axis and angle to horisont
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvFitEllipse<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> points<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> n<FONT COLOR=black>,</FONT> CvBox2D32f<FONT COLOR=black>*</FONT> box <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvMinAreaRect
//    Purpose:
//      For set of points finds enclosing rectangle which has minimal area among all such
//      rectangles. Function uses Toussaint algorithm(rotating calipers)
//    Context:
//    Parameters:
//       points - input points
//       n      - number of points
//       left,
//       bottom,
//       right,
//       top    - indices in input array of most left, bottom, right and top points
//       anchor - coordinates of one of corners of output rectangle
//       vect1,
//       vect2  - two vectors, which represents sides of rectangle which are incident
//                to anchor
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvMinAreaRect<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT><FONT COLOR=black>*</FONT> points<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> n<FONT COLOR=black>,</FONT>
                             <FONT COLOR=blue>int</FONT> left<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> bottom<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> right<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> top<FONT COLOR=black>,</FONT>
                             <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> anchor<FONT COLOR=black>,</FONT>
                             <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> vect1<FONT COLOR=black>,</FONT>
                             <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> vect2 <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvMinEnclosingCircle
//    Purpose:
//      Finds minimal enclosing circle for point set
//    Context:
//    Parameters:
//      seq      - sequence of points
//      center   - center of min enclosing circle
//      radius   - radius of enclosing circle
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMinEnclosingCircle<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> seq<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> center<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> radius <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                  Histogram functions                                   *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvCalcEMD
//    Purpose:    Computes Earth mover distance(and/or lower bound of it) for given pair
//                of signatures. Ground distance can calculated as
//                L1, L2 or C distance between features' coordinate vectors or
//                using user-defined distance function.
//    Context:
//    Parameters:
//      signature1  - first signature - array of size1 *(dims + 1) elements
//      signature2  - second signature - array of size2 *(dims + 1) elements
//      dims        - number of dimensions in feature space. If 0, then
//                    signature1 and signature2 are considered as simple 1D histograms,
//                    else both signatures must look as follows:
//                   (weight_i0, x0_i0, x1_i0, ..., x(dims-1)_i0,
//                     weight_i1, x0_i1, x1_i1, ..., x(dims-1)_i1,
//                     ...
//                     weight_(size1-1),x0_(size1-1),x1_(size1-1,...,x(dims-1)_(size1-1))
//
//                     where weight_ik - weight of ik cluster.
//                     x0_ik,...,x(dims-1)_ik - coordinates of ik cluster.
//
//      dist_type   - CV_DIST_L1, CV_DIST_L2, CV_DIST_C mean one of standard metrics.
//                   ((CvDisType)-1) means user-defined distance function, which is
//                    passes two coordinate vectors and user parameter, and which returns
//                    distance between those feature points.
//      emd         - pointer to calculated emd distance
//      lower_bound - pointer to calculated lower bound.
//                    if 0, this quantity is not calculated(only emd is calculated).
//                    else if calculated lower bound is greater or equal to the value,
//                    stored at this pointer, then the true emd is not calculated, but
//                    is set to that lower_bound.
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>float</FONT>  cvCalcEMD<FONT COLOR=black>(</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> signature1<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> size1<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> signature2<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> size2<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>int</FONT> dims<FONT COLOR=black>,</FONT> CvDisType dist_type<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>float</FONT><FONT COLOR=black>(</FONT><FONT COLOR=black>*</FONT>dist_func<FONT COLOR=black>)(</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> f1<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> f2<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> user_param<FONT COLOR=black>),</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> lower_bound<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> user_param <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvCreateHist
//    Purpose:    Creates histogram
//    Context:
//    Parameters:
//      c_dims - number of dimension in the histogram
//      dims   - array, containing number of bins per each dimension
//      type   - type of histogram. Now, CV_HIST_ARRAY is only supported type.
//      ranges - array of bin ranges.
//      uniform - flag; non 0 if histogram bins are evenly spaced.
//    Returns:
//      Created histogram.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT>  cvCreateHist<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> c_dims<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> dims<FONT COLOR=black>,</FONT>
                                    CvHistType type<FONT COLOR=black>,</FONT>
                                    <FONT COLOR=blue>float</FONT><FONT COLOR=black>**</FONT> ranges <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                                    <FONT COLOR=blue>int</FONT> uniform <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>));</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvSetHistBinRanges
//    Purpose:    Sets histogram bins' ranges
//    Context:
//    Parameters:
//      ranges - array of bin ranges.
//      uniform - flag; non 0 if histogram bins are evenly spaced.
//    Returns:
//      nothing
//    Notes:      if uniform parameter is not NULL then thresh[i][0] - minimum value,
//                thresh[i][1] - maximum value of thresholds for dimension i
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvSetHistBinRanges<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>**</FONT> ranges<FONT COLOR=black>,</FONT>
                                 <FONT COLOR=blue>int</FONT> uniform <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>));</FONT>

<FONT COLOR=darkblue>#define cvSetHistThresh  cvSetHistBinRanges</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvMakeHistHeaderForArray
//    Purpose:    Initializes histogram header and sets
//                its data pointer to given value
//    Context:
//    Parameters:
//      c_dims - number of dimension in the histogram
//      dims   - array, containing number of bins per each dimension
//      hist   - pointer to histogram structure. It will have CV_HIST_ARRAY type.
//      data   - histogram data
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMakeHistHeaderForArray<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>  c_dims<FONT COLOR=black>,</FONT>
                                        <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> dims<FONT COLOR=black>,</FONT>
                                        <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT>
                                        <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> data<FONT COLOR=black>,</FONT>
                                        <FONT COLOR=blue>float</FONT><FONT COLOR=black>**</FONT> ranges <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                                        <FONT COLOR=blue>int</FONT> uniform <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>));</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvReleaseHist
//    Purpose:    Releases histogram header and underlying data
//    Context:
//    Parameters:
//      hist - pointer to released histogram.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvReleaseHist<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>**</FONT> hist <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvClearHist
//    Purpose:    Clears histogram(sets all bins to zero)
//    Context:
//    Parameters:
//      hist - pointer to cleared histogram.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvClearHist<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvQueryHistValue....
//    Purpose:    Returns value or histogram bin, given its cooridinates
//    Context:
//    Parameters:
//      hist - pointer to histogram.
//      idx0 - index for the 1st dimension
//      idx1 - index for the 2nd dimension
//             ...
//      idx  - array of coordinates(for multi-dimensonal histogram)
//    Returns:
//      Value of histogram bin
//    Notes:
//      For non-array histogram function returns 0 if the specified element isn't present
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>float</FONT>  cvQueryHistValue_1D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx0 <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=blue>float</FONT>  cvQueryHistValue_2D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx0<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx1 <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=blue>float</FONT>  cvQueryHistValue_3D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx0<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx1<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx2 <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=blue>float</FONT>  cvQueryHistValue_nD<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> idx <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvGetHistValue....
//    Purpose:    Returns pointer to histogram bin, given its cooridinates
//    Context:
//    Parameters:
//      hist - pointer to histogram.
//      idx0 - index for the 1st dimension
//      idx1 - index for the 2nd dimension
//             ...
//      idx  - array of coordinates(for multi-dimensonal histogram).
//             must have hist->c_dims elements.
//    Returns:
//      Pointer to histogram bin
//    Notes:
//      For non-array histogram function creates a new element if it is not exists.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT>  cvGetHistValue_1D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx0 <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT>  cvGetHistValue_2D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx0<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx1 <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT>  cvGetHistValue_3D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx0<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx1<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> idx2 <FONT COLOR=black>);</FONT>
OPENCVAPI  <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT>  cvGetHistValue_nD<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> idx <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvGetMinMaxHistValue
//    Purpose:    Finds coordinates and numerical values of minimum and maximum
//                histogram bins
//    Context:
//    Parameters:
//      hist - pointer to histogram.
//      idx_min - pointer to array of coordinates for minimum.
//                if not NULL, must have hist->c_dims elements.
//      value_min - pointer to minimum value of histogram( Can be NULL).
//      idx_max - pointer to array of coordinates for maximum.
//                if not NULL, must have hist->c_dims elements.
//      value_max - pointer to maximum value of histogram( Can be NULL).
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvGetMinMaxHistValue<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT>
                                    <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> value_min<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> value_max<FONT COLOR=black>,</FONT>
                                    <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> idx_min <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT> 
                                    <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> idx_max <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>));</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvNormalizeHist
//    Purpose:  Normalizes histogram(such that sum of histogram bins becomes factor)
//    Context:
//    Parameters:
//      hist - pointer to normalized histogram.
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvNormalizeHist<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> factor <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvThreshHist
//    Purpose:  Clears histogram bins that are below specified level
//    Context:
//    Parameters:
//      hist - pointer to histogram.
//      thresh - threshold level
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvThreshHist<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> thresh <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvCompareHist
//    Purpose:  compares two histograms using specified method
//    Context:
//    Parameters:
//      hist1 - first compared histogram.
//      hist2 - second compared histogram.
//      method - comparison method
//    Returns:
//      value, that characterizes similarity(or difference) of two histograms
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvCompareHist<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT>  hist1<FONT COLOR=black>,</FONT>
                               <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT>  hist2<FONT COLOR=black>,</FONT>
                               CvCompareMethod method<FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvCopyHist
//    Purpose:    Copying one histogram to another
//    Context:
//    Parameters:
//      src - source histogram
//      dst - destination histogram
//    Returns:
//    Notes:      if second parameter is pointer to NULL(*dst == 0) then second
//                histogram will be created.
//                both histograms(if second histogram present) must be equal
//                types & sizes
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvCopyHist<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>**</FONT> dst <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvCalcBayesianProb
//    Purpose:    Calculates bayesian probabilistic histograms
//    Context:
//    Parameters:
//      src - array of source histograms
//      number - number of source/destination histograms 
//      dst - array of destination histograms
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvCalcBayesianProb<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>**</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> number<FONT COLOR=black>,</FONT>
                                  <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>**</FONT> dst<FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvCalcHist
//    Purpose:    Calculating histogram from array of one-channel images
//    Context:
//    Parameters:
//      img - array of single-channel images
//      hist - histogram to be calculated. It must have as many dimensions as number of
//             images in <img> array.
//      doNotClear - if not 0, the histogram is not cleared before calculations.
//      mask - optional mask that determines pixels that participate in histogram
//             accumulation.
//    Returns:
//    Notes:      if doNotClear parameter is NULL then histogram clearing before
//                calculating(all values sets to NULL)
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcHist<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>**</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>int</FONT> doNotClear <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>),</FONT>
                          <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>
<FONT COLOR=darkblue>#define cvCalcHistMask(img, mask, hist, doNotClear) cvCalcHist(img, hist, doNotClear, mask)</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvCalcContrastHist
//    Purpose:    Calculates contrast histogram from array of one-channel images
//    Context:
//    Parameters:
//    Returns:
//    Notes:      if dont_clear parameter is NULL then histogram clearing before
//                calculating(all values sets to NULL)
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvCalcContrastHist<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>**</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=blue>int</FONT> doNotClear<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> mask <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvCalcBackProject
//    Purpose:    Calculates back project of histogram
//      img - array of input single-channel images
//      dst - destination single-channel image
//      hist - histogram, used for calculating back project. It must have as many
//             dimensions as the number of images in the <img> array.
//    Context:
//    Parameters:
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcBackProject<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>**</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT>
                                 <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvCalcBackProjectPatch
//    Purpose:    Calculating back project patch of histogram
//    Context:
//    Parameters:
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcBackProjectPatch<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>**</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> range<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> CvCompareMethod method<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=blue>double</FONT> normFactor <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                                  Active contours                                       *
\****************************************************************************************/</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvSnakeImage
//    Purpose:    Updates active contour in order to minimize its cummulative (internal
//                and external) energy.
//    Context:
//    Parameters:
//      src - source image that represent external energy.
//      points - array of points in the snake.
//      length - number of points
//      alpha, beta, gamma - weights of different energy components
//      coeffUsage - if it is CV_ARRAY then previous three parameters are array of 
//                   <length> elements, otherwise each of them is a pointer to
//                   scalar values.
//      win - half-size of search window. 
//      criteria - termination criteria.
//      calcGradient - if not 0, the function uses magnitude of the source image gradient
//                     as external energy, otherwise the source image pixel values
//                     are just used for this purpose.  
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvSnakeImage<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT><FONT COLOR=black>*</FONT> points<FONT COLOR=black>,</FONT>
                            <FONT COLOR=blue>int</FONT>  length<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> alpha<FONT COLOR=black>,</FONT>
                            <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> beta<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> gamma<FONT COLOR=black>,</FONT>
                            CvCoeffType coeffUsage<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT>  win<FONT COLOR=black>,</FONT>
                            <FONT COLOR=darkmagenta>CvTermCriteria</FONT> criteria<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> calcGradient <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>));</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                              Gesture recognition                                      *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvFindHandRegion
//    Purpose:  finds hand region in range image data
//    Context:   
//    Parameters: 
//      points - pointer to the input point's set.
//      count  - the number of the input points.
//      indexs - pointer to the input sequence of the point's indexes
//      line   - pointer to the 3D-line
//      size   - size of the hand in meters 
//      flag   - hand direction's flag (0 - left, -1 - right, 
                 otherwise j-index of the initial image center)
//      center - pointer to the output hand center
//      storage - pointer to the memory storage  
//      numbers - pointer to the output sequence of the point's indexes inside
//                hand region                
//      
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFindHandRegion <FONT COLOR=black>(</FONT><FONT COLOR=darkmagenta>CvPoint3D32f</FONT><FONT COLOR=black>*</FONT> points<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> count<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> indexs<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> line<FONT COLOR=black>,</FONT> CvSize2D32f size<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> flag<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>CvPoint3D32f</FONT><FONT COLOR=black>*</FONT> center<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT> <FONT COLOR=black>**</FONT>numbers<FONT COLOR=black>);</FONT>



<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvFindHandRegionA
//    Purpose:  finds hand region in range image data
//    Context:
//    Parameters:
//      points - pointer to the input point's set.
//      count  - the number of the input points.
//      indexs - pointer to the input sequence of the point's indexes
//      line   - pointer to the 3D-line
//      size   - size of the hand in meters
//      jc - j-index of the initial image center
//      center - pointer to the output hand center
//      storage - pointer to the memory storage
//      numbers - pointer to the output sequence of the point's indexes inside
//                hand region
//
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFindHandRegionA<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvPoint3D32f</FONT><FONT COLOR=black>*</FONT> points<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> count<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> indexs<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> line<FONT COLOR=black>,</FONT> CvSize2D32f size<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> jc<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>CvPoint3D32f</FONT><FONT COLOR=black>*</FONT> center<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT> <FONT COLOR=black>**</FONT>numbers<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvCalcImageHomography
//    Purpose:  calculates the cooficients of the homography matrix
//    Context:
//    Parameters:
//      line   - pointer to the input 3D-line
//      center - pointer to the input hand center
//      intrinsic - intrinsic camera parameters matrix
//      homography - result homography matrix
//
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcImageHomography<FONT COLOR=black>(</FONT><FONT COLOR=blue>float</FONT> <FONT COLOR=black>*</FONT>line<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint3D32f</FONT><FONT COLOR=black>*</FONT> center<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>float</FONT> intrinsic<FONT COLOR=black>[</FONT>3<FONT COLOR=black>][</FONT>3<FONT COLOR=black>],</FONT> <FONT COLOR=blue>float</FONT> homography<FONT COLOR=black>[</FONT>3<FONT COLOR=black>][</FONT>3<FONT COLOR=black>]);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvCreateHandMask
//    Purpose:  creates hand mask image
//    Context:
//    Parameters:
//      numbers - pointer to the input sequence of the point's indexes inside
//                hand region
//      img_mask - pointer to the result mask image
//      roi      - result hand mask ROI
//
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCreateHandMask<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSeq</FONT><FONT COLOR=black>*</FONT> numbers<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>IplImage</FONT> <FONT COLOR=black>*</FONT>img_mask<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvRect</FONT> <FONT COLOR=black>*</FONT>roi<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvCalcProbDensity
//    Purpose:  calculates hand mask probability density
//    Context:
//    Parameters:
//      hist      - pointer to the input image histogram
//      hist_mask - pointer to the input image mask histogram
//      hist_dens - pointer to the result probability density histogram
//
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcProbDensity<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist_mask<FONT COLOR=black>,</FONT>
                                 <FONT COLOR=darkmagenta>CvHistogram</FONT><FONT COLOR=black>*</FONT> hist_dens<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvMaxRect
//    Purpose:  calculates maximum rectangle
//    Context:
//    Parameters:
//      rect1      - pointer to the first input rectangle
//      rect2      - pointer to the second input rectangle
//      max_rect   - pointer to the result maximum rectangle
//
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMaxRect<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvRect</FONT> <FONT COLOR=black>*</FONT>rect1<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvRect</FONT> <FONT COLOR=black>*</FONT>rect2<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvRect</FONT> <FONT COLOR=black>*</FONT>max_rect <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                  Distance Transform                                    *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvDistTransform
//    Purpose:  calculates distance transform of binary image 
//    Context:
//    Parameters:
//      src - source binary image
//      dst - output floating-point image, whose pixel values are distances from
//            the correspondend pixel in the source image to the nearest 0-pixel.
//      disType - type of metric used
//      maskType - size of discrete aperture that approximates the metric.
//      mask - array of 2 (for 3x3 mask) or 3 numbers (for 5x5 mask) that characterizes
//             metric if disType is CV_DIST_USER (user-defined metric)
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvDistTransform<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT> CvDisType disType<FONT COLOR=black>,</FONT>
                               CvDisMaskType maskType<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> mask <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>));</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                                      Thresholds                                        *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvThreshold
//    Purpose: Applies fixed threshold to the grayscale image
//    Context:
//    Parameters:
//      src     - source image
//      dst     - destination image (can be the same as the source image)
//      threshold - threshold value
//      maxValue  - the maximum value of the image pixel
//      type      - thresholding type, must be one of
//                  CV_THRESH_BINARY       - val =(val > Thresh ? maxValue : 0)
//                  CV_THRESH_BINARY_INV   - val =(val > Thresh ? 0   : maxValue)
//                  CV_THRESH_TOZERO       - val =(val > Thresh ? val : 0)
//                  CV_THRESH_TOZERO_INV   - val =(val > Thresh ? 0   : val)
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvThreshold<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  src<FONT COLOR=black>,</FONT>  <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  dst<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>double</FONT>  thresh<FONT COLOR=black>,</FONT>  <FONT COLOR=blue>double</FONT>  maxValue<FONT COLOR=black>,</FONT>
                           CvThreshType type <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvAdaptiveThreshold
//    Purpose: Applies adaptive threshold to the grayscale image
//    Context:
//    Parameters:
//      src     - source image
//      dst     - destination image
//      maxValue  - the maximum value of the image pixel
//      method    - method for the adaptive threshold calculation
                   (now CV_STDDEF_ADAPTIVE_THRESH only)
//      type      - thresholding type, must be one of
//                  CV_THRESH_BINARY       - val =(val > Thresh ? MAX    : 0)
//                  CV_THRESH_BINARY_INV   - val =(val > Thresh ? 0      : MAX)
//                  CV_THRESH_TOZERO       - val =(val > Thresh ? val    : 0)
//                  CV_THRESH_TOZERO_INV   - val =(val > Thresh ? 0      : val)
//      parameters - pointer to the input parameters(for the
//                   CV_STDDEF_ADAPTIVE_THRESH method parameters[0] is size of
//                   the neighborhood thresholding,(one of the 1-(3x3),2-(5x5),or
//                   3-(7x7)), parameters[1] is the value of the minimum variance
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvAdaptiveThreshold<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>      src<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>      dst<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=blue>double</FONT>         maxValue<FONT COLOR=black>,</FONT>
                                   CvAdaptiveThreshMethod method<FONT COLOR=black>,</FONT>
                                   CvThreshType type<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=blue>double</FONT><FONT COLOR=black>*</FONT> parameters <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                     Flood fill                                         *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvFloodFill, cvFloodFill
//    Purpose: The function fills the connected domain, starting from seed pixel
//             while the pixel values in this domain are not far from each other.
//    Context:
//    Parameters:
//      img        - initial image(in the beginning)
//                   which is "repainted" during the function action,
//      seedPoint  - coordinates of the seed point inside image ROI,
//      newVal     - new value of repainted area pixels,
//      loDiff, upDiff - maximal lower and upper differences of the values of
//                   appurtenant to repainted area pixel and one of its
//                   neighbour,
//      comp       - pointer to connected component structure of the
//                   repainted area
//      connectivity - if it is 4, the function looks for 4-connected neighbors,
//                     otherwise it looks for 8-connected neighbors.
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFloodFill<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint</FONT> seedPoint<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>double</FONT> newVal<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> loDiff<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> upDiff<FONT COLOR=black>,</FONT>
                           CvConnectedComp<FONT COLOR=black>*</FONT> comp<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> connectivity <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>4<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                     CAMSHIFT                                           *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCamShift
//    Purpose:
//      Implements CAMSHIFT algorithm - determines object position, size and orientation
//      from the object histogram back project.
//    Context:
//    Parameters:
//      imgProb - back project of the object histogram
//      windowIn - initial search window
//      criteria - iterative search termination criteria 
//      out    - output parameter. Final position of search window and object area
//      box    - width and height (i.e. length) of the object, its center and orientation
//    Returns:
//      Number of iterations made
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>int</FONT>  cvCamShift<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>   imgProb<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvRect</FONT>  windowIn<FONT COLOR=black>,</FONT>
                        <FONT COLOR=darkmagenta>CvTermCriteria</FONT> criteria<FONT COLOR=black>,</FONT> CvConnectedComp<FONT COLOR=black>*</FONT> out<FONT COLOR=black>,</FONT>
                        CvBox2D32f<FONT COLOR=black>*</FONT> box <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvMeanShift
//    Purpose:
//      Implements MeanShift algorithm - determines object position
//      from the object histogram back project.
//    Context:
//    Parameters:
//      imgProb - back project of the object histogram
//      windowIn - initial search window
//      criteria - iterative search termination criteria 
//      out - output parameter. Final position of search window and object area
//    Returns:
//      Number of iterations made
//    Notes:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>int</FONT>  cvMeanShift<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> imgProb<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvRect</FONT>  windowIn<FONT COLOR=black>,</FONT>
                         <FONT COLOR=darkmagenta>CvTermCriteria</FONT> criteria<FONT COLOR=black>,</FONT> CvConnectedComp<FONT COLOR=black>*</FONT> out <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                  Feature detection                                     *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCanny
//    Purpose: Canny edge detection
//    Context:
//    Parameters:
//      src - source byte-depth, single channel image,
//      dst - destination byte-depth, single channel image with edges,
//      apertureSize - size of Sobel operator aperture,
//      lowThreshold,
//      highThreshold - tresholds, applied in hysteresis thresholding
//    Returns:
//    Notes: image gradient magnitude has scale factor 2^(2*apertureSize-3)
//           so user must choose appropriate lowThreshold and highThreshold
//           i.e. if real gradient magnitude is 1, then 3x3 Sobel used in this function
//           will output 8 for apertureSize == 3.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCanny<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> lowThreshold<FONT COLOR=black>,</FONT>
                       <FONT COLOR=blue>double</FONT> highThreshold<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT>  apertureSize <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>3<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvPreCornerDetect
//    Purpose:  Calculating constraint image for corner detection
//              Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy
//    Context:
//    Parameters:
//      src - source image
//      dst - destination feature image
//      apertureSize - Sobel operator aperture size
//    Returns:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvPreCornerDetect<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>int</FONT> apertureSize <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>3<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCalcCornerEigenValsAndVecs
//    Purpose:  Calculates eigen values and vectors of 2x2
//              gradient matrix at every image pixel
//    Context:
//    Parameters:
//      src      - pointer to the source image
//      eigenvv  - destination image, containing two eigen values and
//                 components of two eigen vectors for each raster point
//               ( i.e., this image is 6 times wider than source image )
//      apertureSize - Sobel operator aperture size
//      blockSize  - size of block for summation(averaging block)
//    Returns:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvCornerEigenValsAndVecs<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> eigenvv<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=blue>int</FONT> blockSize<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=blue>int</FONT> apertureSize <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>3<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvCornerMinEigenVal
//    Purpose:  Calculates minimal eigenvalue for 2x2 gradient matrix at
//              every image pixel
//    Context:
//    Parameters:
//      src        - source image
//      eigenval   - minimal eigen value for each point of the source image
//      apertureSize - Sobel operator aperture size
//      blockSize  - size of block for summation(averaging block)
//    Returns:
//F*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvCornerMinEigenVal<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> eigenval<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=blue>int</FONT> blockSize<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=blue>int</FONT> apertureSize <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>3<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvFindCornerSubPix
//    Purpose:
//      Finds corners on the image with sub-pixel accuracy given
//      initial guesses for those corners.
//    Context:
//    Parameters:
//      src        - source image
//      corners    - initial coordinates of corners on input, adjusted coordinates
//                   on output
//      count      - number of corner points
//      win        - search window size for each corner.
//                   actually, for each corner(x,y), the window
//                  (x - win.width .. x + win.width,y - win.height .. y + win_height)
//                   is used.(window  moves with the point after every iteration)
//      zeroZone   - size of zero zone in the middle of the mask.
//      criteria   - This parameter specifies, how many times iterate and what precision
//                   is required.
//    Returns:
//      Nothing
//    Notes:
//      Size of destination ROI is not passed into the function, because
//      it assumes dst ROI size:
//      =(src_size.width - 2, src_size.height - 2) if both kernels are used
//      =(src_size.width - 2, src_size.height)     if horizontal kernel != 0 only.
//      =(src_size.width, src_size.height - 2)     if vertical kernel != 0 only.
F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFindCornerSubPix<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT><FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT>  corners<FONT COLOR=black>,</FONT>
                                    <FONT COLOR=blue>int</FONT> count<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> win<FONT COLOR=black>,</FONT><FONT COLOR=darkmagenta>CvSize</FONT> zeroZone<FONT COLOR=black>,</FONT>
                                    <FONT COLOR=darkmagenta>CvTermCriteria</FONT>  criteria <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvGoodFeaturesToTrack
//    Purpose:
//      Finds strong corners on the image
//    Context:
//    Parameters:
//      image    - input image(IPL_DEPTH_8U,IPL_DEPTH_8S or IPL_DEPTH_32F,single channel)
//      eigImage - temporary image(IPL_DEPTH_32F,single channel),
//                 which will contain minimal eigen value for each point
//      tempImage- temporary image(IPL_DEPTH_32F,single channel),
//                 which is used in non-maxima suppression.
//      corners  - output corners
//      corner_count - number of output corners
//      quality_level - only those corners are selected, which minimal eigen value is
//                      non-less than maximum of minimal eigen values on the image,
//                      multiplied by quality_level. For example, quality_level = 0.1
//                      means that selected corners must be at least 1/10 as good as
//                      the best corner.
//      min_distance - The selected corners(after thresholding using quality_level)
//                     are rerified such that pair-wise distance between them is
//                     non-less than min_distance
//    Returns:
F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvGoodFeaturesToTrack<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> eigImage<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> tempImage<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> corners<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>    corner_count<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=blue>double</FONT>  quality_level<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=blue>double</FONT>  min_distance <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                     Hough Transform                                    *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvHoughLines
//    Purpose:
//      Function detects lines on a binary raster image
//    Context:
//    Parameters:
//      image       - input image
//      rho         - resolution in rho(the minimum difference between two values)
//      theta       - resolution in theta(the minimum difference between two values)
//      threshold   - the pixels number which is enough to plot a line through
//      lines       - output parameters of a line
//                    i line is rho = lines[2*i], theta = lines[2*i + 1]
//      linesNumber - 2*linesNumber is the size of the lines buffer
//    Returns:
//    Notes:
//      the Standard Hough Transform is used in the function
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>  cvHoughLines<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> rho<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> theta<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> threshold<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> lines<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> linesNumber <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvHoughLinesP
//    Purpose:
//      Function detects lines on a binary raster image
//    Context:
//    Parameters:
//      image       - input image
//      rho         - resolution in rho(the minimum difference between two values)
//      theta       - resolution in theta(the minimum difference between two values)
//      threshold   - the pixels number which is enough to plot a line through
//      lineLength  - the minimum accepted length of lines
//      lineGap     - the maximum accepted gap in a line(in pixels)
//      lines       - output parameters of a line
//                      the i line starts in x1 = lines[4*i], y1 = lines[4*i + 1] and
//                      finishes in x2 = lines[4*i + 2], y2 = lines[4*i + 3]
//      linesNumber - 4*linesNumber is the size of lines buffer
//      linesToFind - the maximum number of lines to detect
//    Returns:
//      The number of found lines
//    Notes:
//    The Progressive Probabilistic Hough Transform is implemented in the function. It
//      searches for linesToFind number of lines, taking only those that contain more than
//      lineLength pixels and return. Effectively detects long lines on an image with
//      strong noise.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>  cvHoughLinesP<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> rho<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> theta<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> threshold<FONT COLOR=black>,</FONT>
                            <FONT COLOR=blue>int</FONT> lineLength<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> lineGap<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> lines<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> linesNumber <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvHoughLinesSDiv
//    Purpose:
//      Function detects lines on a binary raster image
//    Context:
//    Parameters:
//      image       - input image
//      rho         - rough resolution in rho(the minimum difference between two values)
//      srn         - the scale factor of a rough rho resolution to a high one
//      theta       - rough resolution in theta(the minimum difference between two values)
//      stn         - the scale factor of a rough theta resolution to a high one
//      threshold   - the pixels number which is enough to plot a line through
//      lines       - output parameters of a line
//                      i line is rho = lines[2*i], theta = lines[2*i + 1]
//      linesNumber - 2*linesNumber is the size of the lines buffer
//    Returns:
//      the number of lines found
//    Notes:
//    the Standard Hough Transform is used in the function
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>  cvHoughLinesSDiv<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> image<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>double</FONT> rho<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> srn<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> theta<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> stn<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>int</FONT> threshold<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> lines<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> lines_number <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                              Geometry functions                                        *
\****************************************************************************************/</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvProject3D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvPoint3D32f</FONT><FONT COLOR=black>*</FONT> points3D<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> count<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> points2D<FONT COLOR=black>,</FONT>
                            <FONT COLOR=blue>int</FONT> xIndx<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> yIndx <FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFitLine3D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvPoint3D32f</FONT><FONT COLOR=black>*</FONT> points<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> count<FONT COLOR=black>,</FONT> CvDisType dist<FONT COLOR=black>,</FONT>
            <FONT COLOR=blue>void</FONT> <FONT COLOR=black>*</FONT>param<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT> reps<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT> aeps<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> line <FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFitLine2D<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> points<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> count<FONT COLOR=black>,</FONT> CvDisType dist<FONT COLOR=black>,</FONT>
            <FONT COLOR=blue>void</FONT> <FONT COLOR=black>*</FONT>param<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT> reps<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT> aeps<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> line <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                              Optical Flow functions                                    *
\****************************************************************************************/</FONT>
<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvCalcOpticalFlowLK( Lucas & Kanade method )
//    Purpose: calculate Optical flow for 2 images using Lucas & Kanade algorithm
//    Context:
//    Parameters:
//            srcA,         // first image
//            srcB,         // second image
//            winSize,      // size of the averaging window used for grouping
//            velx,         //  horizontal
//            vely          //  vertical components of optical flow
//
//    Returns:
//
//    Notes:  1.Optical flow to be computed for every pixel in ROI
//            2.For calculating spatial derivatives we use 3x3 Sobel operator.
//            3.We use the following border mode.
//              The last row or column is replicated for the border
//            ( IPL_BORDER_REPLICATE in IPL ).
//
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcOpticalFlowLK<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> srcA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> srcB<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> winSize<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> velx<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> vely <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvCalcOpticalFlowBM
//    Purpose: calculate Optical flow for 2 images using block matching algorithm
//    Context:
//    Parameters:
//            srcA,         // first image
//            srcB,         // second image
//            blockSize,    // size of basic blocks which are compared
//            shiftSize,    // coordinates increments.
//            maxRange,     // size of the scanned neighborhood.
//            usePrevious,  // use previous(input) velocity field.
//            velx,         //  horizontal
//            vely          //  vertical components of optical flow
//
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcOpticalFlowBM<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> srcA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> srcB<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=darkmagenta>CvSize</FONT> blockSize<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> shiftSize<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=darkmagenta>CvSize</FONT> maxRange<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> usePrevious<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> velx<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> vely <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvCalcOpticalFlowHS(Horn & Schunck method )
//    Purpose: calculate Optical flow for 2 images using Horn & Schunck algorithm
//    Context:
//    Parameters:
//            srcA,         // first image
//            srcB,         // second image
//            int usePrevious, // use previous(input) velocity field.
//            velx,         //  horizontal
//            vely          //  vertical components of optical flow
//            double lambda, // Lagrangian multiplier
//            criteria       // criteria of process termination
//
//    Returns:

//    Notes:  1.Optical flow to be computed for every pixel in ROI
//            2.For calculating spatial derivatives we use 3x3 Sobel operator.
//            3.We use the following border mode.
//              The first and last rows and columns are replicated for the border
//            ( IPL_BORDER_REPLICATE in IPL ).
//F*/</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcOpticalFlowHS<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> srcA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> srcB<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> usePrevious<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> velx<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> vely<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> lambda<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>CvTermCriteria</FONT> criteria <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvCalcOpticalFlowPyrLK
//    Purpose:
//      It is Lucas & Kanade method, modified to use pyramids.
//      Also it does several iterations to get optical flow for
//      every point at every pyramid level.
//      Calculates optical flow between two images for certain set of points.
//    Context:
//    Parameters:
//            imgA     - first frame(time t)
//            imgB     - second frame(time t+1)
//            pyrA     - buffer for pyramid for the first frame.
//                       if the pointer is not NULL, the buffer must have size enough to
//                       store pyramid(from level 1 to level #<level>(see below))
//                      (total size of(imgSize.width+8)*imgSize.height/3
//                        bytes will be enough)).
//            pyrB     - similar to pyrA, but for the second frame.
//
//                       for both parameters above the following rules work:
//                           If image pointer is 0, the function allocates the buffer
//                           internally, calculates pyramid and releases the buffer after
//                           processing.
//                           Else(image should be large enough then) the function calculates
//                           pyramid and stores it in the buffer unless the
//                           CV_LKFLOW_PYR_A[B]_READY flag is set. After function call
//                           both pyramids are calculated and ready-flag for corresponding
//                           image can be set.
//
//            count    - number of feature points
//            winSize  - size of search window on each pyramid level
//            level    - maximal pyramid level number
//                        (if 0, pyramids are not used(single level),
//                          if 1, two levels are used etc.)
//
//            next parameters are arrays of <count> elements.
//            ------------------------------------------------------
//            featuresA - array of points, for which the flow needs to be found
//            featuresB - array of 2D points, containing calculated
//                       new positions of input features(in the second image).
//            status   - array, every element of which will be set to 1 if the flow for the
//                       corresponding feature has been found, 0 else.
//            error    - array of double numbers, containing difference between
//                       patches around the original and moved points
//                      (it is optional parameter, can be NULL).
//            ------------------------------------------------------
//            criteria   - specifies when to stop the iteration process of finding flow
//                         for each point on each pyramid level
//
//            flags      - miscellaneous flags:
//                            CV_LKFLOW_PYR_A_READY - pyramid for the first frame
//                                                    is precalculated before call
//                            CV_LKFLOW_PYR_B_READY - pyramid for the second frame
//                                                    is precalculated before call
//                            CV_LKFLOW_INITIAL_GUESSES - featuresB array holds initial
//                                                        guesses about new features'
//                                                        locations before function call.
//    Returns:
//    Notes:  For calculating spatial derivatives 3x3 Sharr operator is used.
//            The values of pixels beyond the image are determined using border
//            replication.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcOpticalFlowPyrLK<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  imgA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  imgB<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  pyrA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  pyrB<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> featuresA<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> featuresB<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=blue>int</FONT>       count<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=darkmagenta>CvSize</FONT>    winSize<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=blue>int</FONT>       level<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT>     status<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT>    error<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=darkmagenta>CvTermCriteria</FONT> criteria<FONT COLOR=black>,</FONT>
                                      <FONT COLOR=blue>int</FONT>       flags <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvCalcAffineFlowPyrLK
//    Purpose:
//      It is Lucas & Kanade affine tracking method, modified to use pyramids.
//      Also it does several iterations to find flow for
//      every point at every pyramid level.
//      Calculates affine flow between two images for certain set of points.
//    Context:
//    Parameters:
//            imgA     - first frame(time t)
//            imgB     - second frame(time t+1)
//            pyrA     - buffer for pyramid for the first frame.
//                       if the pointer is not NULL, the buffer must have size enough to
//                       store pyramid(from level 1 to level #<level>(see below))
//                      (total size of(imgSize.width+8)*imgSize.height/3
//                        bytes will be enough)).
//            pyrB     - similar to pyrA, but for the second frame.
//
//                       for both parameters above the following rules work:
//                           If image pointer is 0, the function allocates the buffer
//                           internally, calculates pyramid and releases the buffer after
//                           processing.
//                           Else(image should be large enough then) the function calculates
//                           pyramid and stores it in the buffer unless the
//                           CV_LKFLOW_PYR_A[B]_READY flag is set. After function call
//                           both pyramids are calculated and ready-flag for corresponding
//                           image can be set.
//
//            count    - number of feature points
//            winSize  - size of search window on each pyramid level
//            level    - maximal pyramid level number
//                        (if 0, pyramids are not used(single level),
//                          if 1, two levels are used etc.)
//
//            next parameters are arrays of <count> elements.
//            ------------------------------------------------------
//            featuresA - array of points, for which the flow needs to be found
//            featuresB - array of 2D points, containing calculated
//                       new positions of input features(in the second image).
//            matrices - affine transformation matrices,
//            status   - array, every element of which will be set to 1 if the flow for the
//                       corresponding feature has been found, 0 else.
//            error    - array of double numbers, containing difference between
//                       patches around the original and moved points
//                      (it is optional parameter, can be NULL).
//            ------------------------------------------------------
//            criteria   - specifies when to stop the iteration process of finding flow
//                         for each point on each pyramid level
//
//            flags      - miscellaneous flags:
//                            CV_LKFLOW_PYR_A_READY - pyramid for the first frame
//                                                    is precalculated before call
//                            CV_LKFLOW_PYR_B_READY - pyramid for the second frame
//                                                    is precalculated before call
//                            CV_LKFLOW_INITIAL_GUESSES - featuresB array holds initial
//                                                        guesses about new features'
//                                                        locations before function call,
//                                                        matrices array contains guesses
//                                                        about local transformations in
//                                                        the features' neighborhoods.
//    Returns:
//    Notes:  For calculating spatial derivatives 3x3 Sharr operator is used.
//            The values of pixels beyond the image are determined using border
//            replication.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcAffineFlowPyrLK<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  imgA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  imgB<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  pyrA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  pyrB<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> featuresA<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> featuresB<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT>    matrices<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT>       count<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>CvSize</FONT>    winSize<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT>       level<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT>     status<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT>    error<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>CvTermCriteria</FONT> criteria<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT>       flags <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                              Eigen objects functions                                   *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvCalcCovarMatrixEx
//    Purpose: The function calculates a covariance matrix for a group of input objects
//            (images, vectors, etc.).
//    Context:
//    Parameters:  nObjects    - number of source objects
//                 input       - pointer either to array of input objects
//                               or to read callback function(depending on ioFlags)
//                 ioFlags     - input/output flags(see Notes to
//                               cvCalcEigenObjects function)
//                 ioBufSize   - input/output buffer size
//                 userData    - pointer to the structure which contains all necessary
//                               data for the callback functions
//                 avg         - averaged object
//                 covarMatrix - covariance matrix(output parameter; must be allocated
//                               before call)
//
//    Notes:  See Notes to cvCalcEigenObjects function
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcCovarMatrixEx<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> nObjects<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> input<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> ioFlags<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT> ioBufSize<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>uchar</FONT><FONT COLOR=black>*</FONT> buffer<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> userData<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> avg<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> covarMatrix <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvCalcEigenObjects
//    Purpose: The function calculates an orthonormal eigen basis and a mean(averaged)
//             object for a group of input objects(images, vectors, etc.).
//    Context:
//    Parameters: nObjects  - number of source objects
//                input     - pointer either to array of input objects
//                            or to read callback function(depending on ioFlags)
//                output    - pointer either to output eigen objects
//                            or to write callback function(depending on ioFlags)
//                ioFlags   - input/output flags(see Notes)
//                ioBufSize - input/output buffer size
//                userData  - pointer to the structure which contains all necessary
//                            data for the callback functions
//                calcLimit - determines the calculation finish conditions
//                avg       - averaged object(has the same size as ROI)
//                eigVals   - pointer to corresponding eigen values(array of <nObjects>
//                            elements in descending order)
//
//    Notes: 1. input/output data(that is, input objects and eigen ones) may either
//              be allocated in the RAM or be read from/written to the HDD(or any
//              other device) by read/write callback functions. It depends on the
//              value of ioFlags paramater, which may be the following:
//                  CV_EIGOBJ_NO_CALLBACK, or 0;
//                  CV_EIGOBJ_INPUT_CALLBACK;
//                  CV_EIGOBJ_OUTPUT_CALLBACK;
//                  CV_EIGOBJ_BOTH_CALLBACK, or
//                            CV_EIGOBJ_INPUT_CALLBACK | CV_EIGOBJ_OUTPUT_CALLBACK.
//              The callback functions as well as the user data structure must be
//              developed by the user.
//
//           2. If ioBufSize = 0, or it's too large, the function dermines buffer size
//              itself.
//
//           3. Depending on calcLimit parameter, calculations are finished either if
//              eigenfaces number comes up to certain value or the relation of the
//              current eigenvalue and the largest one comes down to certain value
//             (or any of the above conditions takes place). The calcLimit->type value
//              must be CV_TERMCRIT_NUMB, CV_TERMCRIT_EPS or
//              CV_TERMCRIT_NUMB | CV_TERMCRIT_EPS. The function returns the real
//              values calcLimit->maxIter and calcLimit->epsilon.
//
//           4. eigVals may be equal to NULL(if you don't need eigen values in further).
//
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalcEigenObjects<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> nObjects<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> input<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> output<FONT COLOR=black>,</FONT>
                                    <FONT COLOR=blue>int</FONT> ioFlags<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> ioBufSize<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> userData<FONT COLOR=black>,</FONT>
                                    <FONT COLOR=darkmagenta>CvTermCriteria</FONT><FONT COLOR=black>*</FONT> calcLimit<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> avg<FONT COLOR=black>,</FONT>
                                    <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> eigVals <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvCalcDecompCoeff
//    Purpose: The function calculates one decomposition coefficient of input object
//             using previously calculated eigen object and the mean(averaged) object
//    Context:
//    Parameters:  obj     - input object
//                 eigObj  - eigen object
//                 avg     - averaged object
//
//    Returns: decomposition coefficient value or large negative value(if error)
//
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvCalcDecompCoeff<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> obj<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> eigObj<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> avg <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Names: cvEigenDecomposite
//    Purpose: The function calculates all decomposition coefficients for input object
//             using previously calculated eigen objects basis and the mean(averaged)
//             object
//
//    Parameters:  obj         - input object
//                 nEigObjs    - number of eigen objects
//                 eigInput    - pointer either to array of pointers to eigen objects
//                               or to read callback function(depending on ioFlags)
//                 ioFlags     - input/output flags
//                 userData    - pointer to the structure which contains all necessary
//                               data for the callback function
//                 avg         - averaged object
//                 coeffs      - calculated coefficients(output data)
//
//    Notes:   see notes to cvCalcEigenObjects function
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvEigenDecomposite<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> obj<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> nEigObjs<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> eigInput<FONT COLOR=black>,</FONT>
                                    <FONT COLOR=blue>int</FONT> ioFlags<FONT COLOR=black>,</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> userData<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> avg<FONT COLOR=black>,</FONT>
                                    <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> coeffs <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvEigenProjection
//    Purpose: The function calculates object projection to the eigen sub-space(restores
//             an object) using previously calculated eigen objects basis, mean(averaged)
//             object and decomposition coefficients of the restored object
//    Context:
//    Parameters:  nEigObjs    - number of eigen objects
//                 eigInput    - pointer either to array of pointers to eigen objects
//                               or to read callback function(depending on ioFlags)
//                 ioFlags     - input/output flags
//                 userData    - pointer to the structure which contains all necessary
//                               data for the callback function
//                 coeffs      - array of decomposition coefficients
//                 avg         - averaged object
//                 proj        - object projection(output data)
//
//    Notes:   see notes for cvCalcEigenObjects function
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvEigenProjection<FONT COLOR=black>(</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> eigInput<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> nEigObjs<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> ioFlags<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> userData<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> coeffs<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> avg<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> proj <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                              HMM(Hidden Markov Models)                                *
\****************************************************************************************/</FONT>


<FONT COLOR=darkblue>#define CV_COUNT_OBS(roi, win, delta, result)                                            \</FONT>
<FONT COLOR=black>{</FONT>                                                                                           <FONT COLOR=black>(</FONT>result<FONT COLOR=black>)</FONT><FONT COLOR=black>-&gt;</FONT>width  <FONT COLOR=black>=</FONT><FONT COLOR=black>((</FONT>roi<FONT COLOR=black>)</FONT><FONT COLOR=black>-&gt;</FONT>width  <FONT COLOR=black>-</FONT><FONT COLOR=black>(</FONT>win<FONT COLOR=black>)</FONT><FONT COLOR=black>-&gt;</FONT>width  <FONT COLOR=black>+</FONT><FONT COLOR=black>(</FONT>delta<FONT COLOR=black>)</FONT><FONT COLOR=black>-&gt;</FONT>width<FONT COLOR=black>)</FONT><FONT COLOR=black>/</FONT><FONT COLOR=black>(</FONT>delta<FONT COLOR=black>)</FONT><FONT COLOR=black>-&gt;</FONT>width<FONT COLOR=black>;</FONT>     <FONT COLOR=black>(</FONT>result<FONT COLOR=black>)</FONT><FONT COLOR=black>-&gt;</FONT>height <FONT COLOR=black>=</FONT><FONT COLOR=black>((</FONT>roi<FONT COLOR=black>)</FONT><FONT COLOR=black>-&gt;</FONT>height <FONT COLOR=black>-</FONT><FONT COLOR=black>(</FONT>win<FONT COLOR=black>)</FONT><FONT COLOR=black>-&gt;</FONT>height <FONT COLOR=black>+</FONT><FONT COLOR=black>(</FONT>delta<FONT COLOR=black>)</FONT><FONT COLOR=black>-&gt;</FONT>height<FONT COLOR=black>)</FONT><FONT COLOR=black>/</FONT><FONT COLOR=black>(</FONT>delta<FONT COLOR=black>)</FONT><FONT COLOR=black>-&gt;</FONT>height<FONT COLOR=black>;</FONT><FONT COLOR=black>}</FONT>

<FONT COLOR=darkgreen>//*F//////////////////////////////////////////////////////////////////////////////////////</FONT>
<FONT COLOR=darkgreen>//    Name: cvCreate2DHMM</FONT>
<FONT COLOR=darkgreen>//    Purpose: The function allocates memory for 2-dimensional embedded HMM model</FONT>
<FONT COLOR=darkgreen>//             after you finish work with created HMM you must free memory</FONT>
<FONT COLOR=darkgreen>//             by calling cvRelease2DHMM function</FONT>
<FONT COLOR=darkgreen>//    Context:</FONT>
<FONT COLOR=darkgreen>//    Parameters: stateNumber - array of hmm sizes(size of array == state_number[0]+1 )</FONT>
<FONT COLOR=darkgreen>//                numMix - number of gaussian mixtures in low-level HMM states</FONT>
<FONT COLOR=darkgreen>//                          size of array is defined by previous array values</FONT>
<FONT COLOR=darkgreen>//                obsSize - length of observation vectors</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//    Returns:</FONT>
<FONT COLOR=darkgreen>//      Created 2D HMM.</FONT>
<FONT COLOR=darkgreen>//    Notes: stateNumber[0] - number of states in external HMM.</FONT>
<FONT COLOR=darkgreen>//           stateNumber[i] - number of states in embedded HMM</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//           example for face recognition: state_number = { 5 3 6 6 6 3 },</FONT>
<FONT COLOR=darkgreen>//                                         length of num_mix array = 3+6+6+6+3 = 24</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//F*/</FONT>
OPENCVAPI  CvEHMM<FONT COLOR=black>*</FONT>  cvCreate2DHMM<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> stateNumber<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> numMix<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> obsSize <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>//*F///////////////////////////////////////////////////////////////////////////////////////</FONT>
<FONT COLOR=darkgreen>//    Name: cvRelease2DHMM</FONT>
<FONT COLOR=darkgreen>//    Purpose: The function free memory used by CvEHMM structure</FONT>
<FONT COLOR=darkgreen>//    Context:</FONT>
<FONT COLOR=darkgreen>//    Parameters: hmm - address of pointer to CvEHMM structure</FONT>
<FONT COLOR=darkgreen>//    Returns:</FONT>
<FONT COLOR=darkgreen>//    Notes:  function set *hmm = 0</FONT>
<FONT COLOR=darkgreen>//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvRelease2DHMM<FONT COLOR=black>(</FONT> CvEHMM<FONT COLOR=black>**</FONT> hmm <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>//*F///////////////////////////////////////////////////////////////////////////////////////</FONT>
<FONT COLOR=darkgreen>//    Name: cvCreateObsInfo</FONT>
<FONT COLOR=darkgreen>//    Purpose: The function allocates memory for CvImgObsInfo structure</FONT>
<FONT COLOR=darkgreen>//             after you finish working with allocated structure - destroy it</FONT>
<FONT COLOR=darkgreen>//             by  cvReleaseObsInfo</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//    Context:</FONT>
<FONT COLOR=darkgreen>//    Parameters: obs_info - addres of pointer to CvImgObsInfo structure</FONT>
<FONT COLOR=darkgreen>//                num_obs  - number of horizontal and vertical observations.</FONT>
<FONT COLOR=darkgreen>//                           Total number of allocated observation vectors</FONT>
<FONT COLOR=darkgreen>//                           will be   num_obs.width*num_obs.height</FONT>
<FONT COLOR=darkgreen>//                obs_size - length of observation vector</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//    Returns:  Parameter obs_info is filled.</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//    Notes: If you extracts observations from image use CV_COUNT_OBS macros</FONT>
<FONT COLOR=darkgreen>//           for computing "num_obs" parameter:</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//           CV_COUNT_OBS( &roi, &obs, &delta, &num_obs)</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//                          here CvSize roi   - image ROI</FONT>
<FONT COLOR=darkgreen>//                               CvSize obs   - size of image block</FONT>
<FONT COLOR=darkgreen>//                               CvSize delta - horizontal and vertical shift</FONT>
<FONT COLOR=darkgreen>//                               CvSize num_obs - output parameter to be computed</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//           macros CV_COUNT_OBS do the following:</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//             num_obs.width  = floor((roi.width -  obs.width +  delta.width )/ delta.width);</FONT>
<FONT COLOR=darkgreen>//             num_obs.height = floor((roi.height - obs.height + delta.height)/delta.height);</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//F*/</FONT>
OPENCVAPI  CvImgObsInfo<FONT COLOR=black>*</FONT>  cvCreateObsInfo<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> numObs<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> obsSize <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>//*F///////////////////////////////////////////////////////////////////////////////////////</FONT>
<FONT COLOR=darkgreen>//    Name: cvReleaseObsInfo</FONT>
<FONT COLOR=darkgreen>//    Purpose: The function free memory used by CvImgObsInfo structure</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//    Context:</FONT>
<FONT COLOR=darkgreen>//    Parameters: obs_info - address of pointer to CvImgObsInfo structure</FONT>
<FONT COLOR=darkgreen>//    Returns:</FONT>
<FONT COLOR=darkgreen>//    Notes:  function sets *obs_info = 0</FONT>
<FONT COLOR=darkgreen>//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvReleaseObsInfo<FONT COLOR=black>(</FONT> CvImgObsInfo<FONT COLOR=black>**</FONT> obs_info <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>//*F//////////////////////////////////////////////////////////////////////////////////////</FONT>
<FONT COLOR=darkgreen>//    Name: cvImgToObs_DCT</FONT>
<FONT COLOR=darkgreen>//    Purpose: The function takes as input an image and returns the sequnce of observations</FONT>
<FONT COLOR=darkgreen>//             to be used with an embedded HMM; Each observation is top-left block of DCT</FONT>
<FONT COLOR=darkgreen>//             coefficient matrix.</FONT>
<FONT COLOR=darkgreen>//    Context:</FONT>
<FONT COLOR=darkgreen>//    Parameters: img     - pointer to the original image</FONT>
<FONT COLOR=darkgreen>//                obs     - pointer to resultant observation vectors</FONT>
<FONT COLOR=darkgreen>//                dctSize - size of the block for which DCT is calculated</FONT>
<FONT COLOR=darkgreen>//                obsSize - size of top-left block of DCT coeffs matrix, which is treated</FONT>
<FONT COLOR=darkgreen>//                          as observation. Each observation vector consists of</FONT>
<FONT COLOR=darkgreen>//                          obsSize.width * obsSize.height floats.</FONT>
<FONT COLOR=darkgreen>//                          The following conditions should be satisfied:</FONT>
<FONT COLOR=darkgreen>//                          0 &lt; objSize.width &lt;= dctSize.width,</FONT>
<FONT COLOR=darkgreen>//                          0 &lt; objSize.height &lt;= dctSize.height.</FONT>
<FONT COLOR=darkgreen>//                delta   - dctBlocks are overlapped and this parameter specifies horizontal</FONT>
<FONT COLOR=darkgreen>//                          and vertical shift.</FONT>
<FONT COLOR=darkgreen>//    Returns:</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//    Notes:</FONT>
<FONT COLOR=darkgreen>//      The algorithm is following:</FONT>
<FONT COLOR=darkgreen>//          1. First, number of observation vectors per row and per column are calculated:</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//             Nx = floor((roi.width - dctSize.width + delta.width)/delta.width);</FONT>
<FONT COLOR=darkgreen>//             Ny = floor((roi.height - dctSize.height + delta.height)/delta.height);</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//             So, total number of observation vectors is Nx*Ny, and total size of</FONT>
<FONT COLOR=darkgreen>//             array obs must be &gt;= Nx*Ny*obsSize.width*obsSize.height*sizeof(float).</FONT>
<FONT COLOR=darkgreen>//          2. Observation vectors are calculated in the following loop</FONT>
<FONT COLOR=darkgreen>//             ( actual implementation may be different ), where</FONT>
<FONT COLOR=darkgreen>//               I[x1:x2,y1:y2] means block of pixels from source image with</FONT>
<FONT COLOR=darkgreen>//               x1 &lt;= x &lt; x2, y1 &lt;= y &lt; y2,</FONT>
<FONT COLOR=darkgreen>//               D[x1:x2,y1:y2] means sub matrix of DCT matrix D.</FONT>
<FONT COLOR=darkgreen>//               O[x,y] means observation vector that corresponds to position</FONT>
<FONT COLOR=darkgreen>//              (x*delta.width,y*delta.height) in the source image</FONT>
<FONT COLOR=darkgreen>//             ( all indices are counted from 0 ).</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//               for( y = 0; y &lt; Ny; y++ )</FONT>
<FONT COLOR=darkgreen>//               {</FONT>
<FONT COLOR=darkgreen>//                   for( x = 0; x &lt; Nx; x++ )</FONT>
<FONT COLOR=darkgreen>//                   {</FONT>
<FONT COLOR=darkgreen>//                       D = DCT(I[x*delta.width : x*delta.width + dctSize.width,</FONT>
<FONT COLOR=darkgreen>//                                  y*delta.height : y*delta.height + dctSize.height]);</FONT>
<FONT COLOR=darkgreen>//                       O[x,y] = D[0:obsSize.width, 0:obsSize.height];</FONT>
<FONT COLOR=darkgreen>//                   }</FONT>
<FONT COLOR=darkgreen>//               }</FONT>
<FONT COLOR=darkgreen>//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvImgToObs_DCT<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> obs<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> dctSize<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>CvSize</FONT> obsSize<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> delta <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>//*F//////////////////////////////////////////////////////////////////////////////////////</FONT>
<FONT COLOR=darkgreen>//    Name: cvUniformImgSegm</FONT>
<FONT COLOR=darkgreen>//    Purpose: The uniformly segments all observation vectors extracted from image</FONT>
<FONT COLOR=darkgreen>//    Context:</FONT>
<FONT COLOR=darkgreen>//    Parameters: obs_info - observations structure</FONT>
<FONT COLOR=darkgreen>//                hmm      - 2D embedded HMM structure</FONT>
<FONT COLOR=darkgreen>//</FONT>
<FONT COLOR=darkgreen>//    Returns:</FONT>
<FONT COLOR=darkgreen>//    Notes:</FONT>
<FONT COLOR=darkgreen>//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvUniformImgSegm<FONT COLOR=black>(</FONT> CvImgObsInfo<FONT COLOR=black>*</FONT> obs_info<FONT COLOR=black>,</FONT> CvEHMM<FONT COLOR=black>*</FONT> ehmm <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvInitMixSegm
//    Purpose: The function implements the mixture segmentation of the states
//             of the embedded HMM
//
//    Context: used with the Viterbi training of the embedded HMM
//             Function uses K-Means algorithm for clustering.
//
//    Parameters:  obs_info_array - array of pointers to image observations
//                 num_img - length of above array
//                 hmm - pointer to HMM structure
//
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvInitMixSegm<FONT COLOR=black>(</FONT> CvImgObsInfo<FONT COLOR=black>**</FONT> obs_info_array<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>int</FONT> num_img<FONT COLOR=black>,</FONT> CvEHMM<FONT COLOR=black>*</FONT> hmm <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvEstimHMMStateParams
//    Purpose: function calculates means, variances, weights of every Gaussian mixture
//             of every low-level state of embedded HMM
//    Context:
//    Parameters:  obs_info_array - array of pointers to observation structures
//                 num_img  - length of above array
//                 hmm      - hmm structure
//
//    Returns:
//
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvEstimateHMMStateParams<FONT COLOR=black>(</FONT> CvImgObsInfo<FONT COLOR=black>**</FONT> obs_info_array<FONT COLOR=black>,</FONT>
                                        <FONT COLOR=blue>int</FONT> num_img<FONT COLOR=black>,</FONT> CvEHMM<FONT COLOR=black>*</FONT> hmm <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvEstimateTransProb
//    Purpose: function computes transition probability matrices of embedded HMM
//             given observations segmentation
//
//    Context:
//    Parameters:  obs_info_array - array of pointers to observation structures
//                 num_img  - length of above array
//                 hmm      - hmm structure
//
//    Returns:
//
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvEstimateTransProb<FONT COLOR=black>(</FONT> CvImgObsInfo<FONT COLOR=black>**</FONT> obs_info_array<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=blue>int</FONT> num_img<FONT COLOR=black>,</FONT> CvEHMM<FONT COLOR=black>*</FONT> hmm <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvEstimateTransProb
//    Purpose: function computes probabilities of appearing observations at any state
//           ( i.e. compute P(obs|state) for every pair(obs,state) )
//    Context:
//    Parameters:  obs_info - observations structure
//                 hmm      - hmm structure
//
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvEstimateObsProb<FONT COLOR=black>(</FONT> CvImgObsInfo<FONT COLOR=black>*</FONT> obs_info<FONT COLOR=black>,</FONT>
                                   CvEHMM<FONT COLOR=black>*</FONT> hmm <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvEViterbi  (Embedded Viterbi)
//    Purpose: The function calculates the embedded Viterbi algorithm
//    Context:
//    Parameters:
//                obs_info - observations structure
//                hmm      - hmm structure
//
//    Returns: the Embedded Viterbi logarithmic probability.
//             Observations, stored in of obs_info structure are segmented
//           ( but new segmentation does not affect mixture segmentation or
//               states parameters )
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>float</FONT>  cvEViterbi<FONT COLOR=black>(</FONT> CvImgObsInfo<FONT COLOR=black>*</FONT> obs_info<FONT COLOR=black>,</FONT> CvEHMM<FONT COLOR=black>*</FONT> hmm <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: cvMixSegmL2
//    Purpose: function clusters observation vectors from several images
//             given observations segmentation.
//             Euclidean distance used for clustering vectors.
//             Centers of clusters are given means of every mixture
//
//    Context: in HMM face recognition used after Viterbi segmentation
//    Parameters:  obs_info_array - array of pointers to observation structures
//                 num_img  - length of above array
//                 hmm      - hmm structure
//
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMixSegmL2<FONT COLOR=black>(</FONT> CvImgObsInfo<FONT COLOR=black>**</FONT> obs_info_array<FONT COLOR=black>,</FONT>
                             <FONT COLOR=blue>int</FONT> num_img<FONT COLOR=black>,</FONT> CvEHMM<FONT COLOR=black>*</FONT> hmm <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/* end of HMM functions*/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name: KMeans
//    Purpose: The function implements the K means algorithm, to cluster an array of sample
//             vectors in a number of classes specified by numClusters
//    Context:
//    Parameters:  numClunster - the number of clusters
//                 samples - the array of sample vectors
//                 numSamples - the number of samples
//                 VecSize - the size of each sample vector
//                 termcrit.eps - the convergence error; the iterations to find the best cluster
//                         centers will stop, when the value of the cost function at consecutive
//                         iterations falls below this threshold
//                 cluster - characteristic array. for every input vector indicates cluster
//
//    Returns: error code
//
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvKMeans<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> num_clusters<FONT COLOR=black>,</FONT> CvVect32f<FONT COLOR=black>*</FONT> samples<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> num_samples<FONT COLOR=black>,</FONT>
                          <FONT COLOR=blue>int</FONT> vec_size<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvTermCriteria</FONT> termcrit<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> cluster  <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                               Undistortion functions                                  *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F//////////////////////////////////////////////////////////////////////////////////////
//    Name: cvUnDistortOnce
//    Purpose: The function corrects radial and tangential image distortion using known
//             matrix of the camera intrinsic parameters and distortion coefficients
//    Context:
//    Parameters:  srcImage    - source(distorted) image
//                 dstImage    - output(undistorted) image
//                 intrMatrix  - matrix of the camera intrinsic parameters
//                 distCoeffs  - vector of the distortion coefficients(k1, k2, p1 and p2)
//                 interpolate - interpolation toggle(optional parameter)
//
//    Notes:   1. If interpolate = 0, interpolation disabled;
//                else(default) bilinear interpolation is used.
//             2. If p1 = p2 = 0, function acts faster.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvUnDistortOnce<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> srcImage<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dstImage<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> intrMatrix<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> distCoeffs<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> interpolate <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F//////////////////////////////////////////////////////////////////////////////////////
//    Name: cvUnDistortInit
//    Purpose: The function calculates arrays of distorted points indices and
//             interpolation coefficients for cvUnDistort function using known
//             matrix of the camera intrinsic parameters and distortion coefficients
//    Context:
//    Parameters:  srcImage    - source(distorted) image
//                 intrMatrix  - matrix of the camera intrinsic parameters
//                 distCoeffs  - vector of the distortion coefficients(k1, k2, p1 and p2)
//                 data        - distortion data array
//                 interpolate - interpolation toggle(optional parameter)
//
//    Notes:  1. If interpolate=0, interpolation disabled;
//               else(default) bilinear interpolation is used.
//            2. Array data must be allocated before. If interpolate = 0, its length
//               must be size.width*size.height elements; else 3*size.width*size.height.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvUnDistortInit<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> srcImage<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> intrMatrix<FONT COLOR=black>,</FONT> <FONT COLOR=blue>float</FONT><FONT COLOR=black>*</FONT> distCoeffs<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> data<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> interpolate <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F//////////////////////////////////////////////////////////////////////////////////////
//    Name: cvUnDistort
//    Purpose: The function corrects radial and tangential distortion in the frame
//             using previousely calculated arrays of distorted points indices and
//             undistortion coefficients
//    Context:
//    Parameters:  srcImage    - source(distorted) image
//                 dstImage    - output(undistorted) image
//                 data        - distortion data array
//                 interpolate - interpolation toggle(optional parameter)
//
//    Notes:  1. If interpolate=0, interpolation disabled;
//               else(default) bilinear interpolation is used.
//            2. Array data must be allocated and calculated by the cvUnDistortInit
//               function before. If interpolate = 0, its length must be
//               size.width*size.height elements; else 3*size.width*size.height.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvUnDistort<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> srcImage<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> dstImage<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> data<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> interpolate <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>1<FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                               Calibration functions                                   *
\****************************************************************************************/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalibrateCamera<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>           numImages<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>          numPoints<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=darkmagenta>CvSize</FONT>        imageSize<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> imagePoints32f<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=darkmagenta>CvPoint3D32f</FONT><FONT COLOR=black>*</FONT> objectPoints32f<FONT COLOR=black>,</FONT>
                                   CvVect32f     distortion32f<FONT COLOR=black>,</FONT>
                                   CvMatr32f     cameraMatrix32f<FONT COLOR=black>,</FONT>
                                   CvVect32f     transVects32f<FONT COLOR=black>,</FONT>
                                   CvMatr32f     rotMatrs32f<FONT COLOR=black>,</FONT>
                                   <FONT COLOR=blue>int</FONT>           useIntrinsicGuess<FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvCalibrateCamera_64d<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>           numImages<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>          numPoints<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=darkmagenta>CvSize</FONT>        imageSize<FONT COLOR=black>,</FONT>
                                       CvPoint2D64d<FONT COLOR=black>*</FONT> imagePoints<FONT COLOR=black>,</FONT>
                                       CvPoint3D64d<FONT COLOR=black>*</FONT> objectPoints<FONT COLOR=black>,</FONT>
                                       CvVect64d     distortion<FONT COLOR=black>,</FONT>
                                       CvMatr64d     cameraMatrix<FONT COLOR=black>,</FONT>
                                       CvVect64d     transVects<FONT COLOR=black>,</FONT>
                                       CvMatr64d     rotMatrs<FONT COLOR=black>,</FONT>
                                       <FONT COLOR=blue>int</FONT>           useIntrinsicGuess <FONT COLOR=black>);</FONT>


OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFindExtrinsicCameraParams<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>           numPoints<FONT COLOR=black>,</FONT>
                                             <FONT COLOR=darkmagenta>CvSize</FONT>        imageSize<FONT COLOR=black>,</FONT>
                                             <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> imagePoints32f<FONT COLOR=black>,</FONT>
                                             <FONT COLOR=darkmagenta>CvPoint3D32f</FONT><FONT COLOR=black>*</FONT> objectPoints32f<FONT COLOR=black>,</FONT>
                                             CvVect32f     focalLength32f<FONT COLOR=black>,</FONT>
                                             <FONT COLOR=darkmagenta>CvPoint2D32f</FONT>  principalPoint32f<FONT COLOR=black>,</FONT>
                                             CvVect32f     distortion32f<FONT COLOR=black>,</FONT>
                                             CvVect32f     rotVect32f<FONT COLOR=black>,</FONT>
                                             CvVect32f     transVect32f<FONT COLOR=black>);</FONT>


OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFindExtrinsicCameraParams_64d<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>           numPoints<FONT COLOR=black>,</FONT>
                                                 <FONT COLOR=darkmagenta>CvSize</FONT>        imageSize<FONT COLOR=black>,</FONT>
                                                 CvPoint2D64d<FONT COLOR=black>*</FONT> imagePoints<FONT COLOR=black>,</FONT>
                                                 CvPoint3D64d<FONT COLOR=black>*</FONT> objectPoints<FONT COLOR=black>,</FONT>
                                                 CvVect64d     focalLength<FONT COLOR=black>,</FONT>
                                                 CvPoint2D64d  principalPoint<FONT COLOR=black>,</FONT>
                                                 CvVect64d     distortion<FONT COLOR=black>,</FONT>
                                                 CvVect64d     rotVect<FONT COLOR=black>,</FONT>
                                                 CvVect64d     transVect<FONT COLOR=black>);</FONT>


OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvRodrigues<FONT COLOR=black>(</FONT> CvMatr32f       rotMatr32f<FONT COLOR=black>,</FONT>
                             CvVect32f       rotVect32f<FONT COLOR=black>,</FONT>
                             CvMatr32f       Jacobian32f<FONT COLOR=black>,</FONT>
                             CvRodriguesType convType<FONT COLOR=black>);</FONT>


OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvRodrigues_64d<FONT COLOR=black>(</FONT> CvMatr64d       rotMatr<FONT COLOR=black>,</FONT>
                                 CvVect64d       rotVect<FONT COLOR=black>,</FONT>
                                 CvMatr64d       Jacobian<FONT COLOR=black>,</FONT>
                                 CvRodriguesType convType<FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvProjectPoints<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>             numPoints<FONT COLOR=black>,</FONT>
                                 CvPoint3D64d<FONT COLOR=black>*</FONT>   objectPoints<FONT COLOR=black>,</FONT>
                                 CvVect64d       rotVect<FONT COLOR=black>,</FONT>
                                 CvVect64d       transVect<FONT COLOR=black>,</FONT>
                                 CvVect64d       focalLength<FONT COLOR=black>,</FONT>
                                 CvPoint2D64d    principalPoint<FONT COLOR=black>,</FONT>
                                 CvVect64d       distortion<FONT COLOR=black>,</FONT>
                                 CvPoint2D64d<FONT COLOR=black>*</FONT>   imagePoints<FONT COLOR=black>,</FONT>
                                 CvVect64d       derivPointsRot<FONT COLOR=black>,</FONT>
                                 CvVect64d       derivPointsTrans<FONT COLOR=black>,</FONT>
                                 CvVect64d       derivPointsFocal<FONT COLOR=black>,</FONT>
                                 CvVect64d       derivPointsPrincipal<FONT COLOR=black>,</FONT>
                                 CvVect64d       derivPointsDistort<FONT COLOR=black>);</FONT>

OPENCVAPI <FONT COLOR=blue>void</FONT> cvProjectPointsSimple<FONT COLOR=black>(</FONT>  <FONT COLOR=blue>int</FONT> numPoints<FONT COLOR=black>,</FONT>
                                    CvPoint3D64d <FONT COLOR=black>*</FONT> objectPoints<FONT COLOR=black>,</FONT>
                                    CvVect64d rotMatr<FONT COLOR=black>,</FONT>
                                    CvVect64d transVect<FONT COLOR=black>,</FONT>
                                    CvMatr64d cameraMatrix<FONT COLOR=black>,</FONT>
                                    CvVect64d distortion<FONT COLOR=black>,</FONT>
                                    CvPoint2D64d<FONT COLOR=black>*</FONT> imagePoints<FONT COLOR=black>);</FONT>
                                    
<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:    cvFindChessBoardCornerGuesses
//    Purpose:
//      Function finds first approximation of internal corners on the chess board.
//    Context:
//    Parameters:
//      img      - source halftone image
//      thresh   - temporary image where the thresholded source image will be stored.
//      etalon_size - number of corners per each column and each row
//      corners  - pointer to found points array
//                 (must have at least etalon_size.width*etalon.height element).
//      corner_count - number of found corners
//    Returns:
//
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>  cvFindChessBoardCornerGuesses<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> thresh<FONT COLOR=black>,</FONT>
                                            <FONT COLOR=darkmagenta>CvMemStorage</FONT><FONT COLOR=black>*</FONT> storage<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvSize</FONT> etalon_size<FONT COLOR=black>,</FONT>
                                            <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> corners<FONT COLOR=black>,</FONT>
                                            <FONT COLOR=blue>int</FONT> <FONT COLOR=black>*</FONT>corner_count <FONT COLOR=gray>CV_DEFAULT</FONT><FONT COLOR=black>(</FONT>0<FONT COLOR=black>));</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                                      POSIT(POse from ITeration)                       *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvCreatePOSITObject
//    Purpose:    Allocate and Initialize CvPOSITObject structure
//                before process cvPOSIT
//    Context:
//    Parameters:
//                  points - pointer to source object points given in
//                           object related coordinate system
//                  numPoints - number of object points
//                  ppObject - address of pointer to CvPOSITObject(returned)
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  CvPOSITObject<FONT COLOR=black>*</FONT>  cvCreatePOSITObject<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvPoint3D32f</FONT><FONT COLOR=black>*</FONT> points<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> numPoints <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvPOSIT
//    Purpose:    performs POSIT algorithm
//
//    Context:
//    Parameters:
//                  pObject - pointer to CvPOSITObject filled with prev. function
//                  imagePoints - pointer to source object image points given in
//                                camera related coordinate system
//                  focalLength - focal length of camera
//                  criteria - stop criteria.
//                  rotation - rotation matrix
//                  translation - translation vector(from camera to
//                                first point of object )
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvPOSIT<FONT COLOR=black>(</FONT>  CvPOSITObject<FONT COLOR=black>*</FONT> pObject<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvPoint2D32f</FONT><FONT COLOR=black>*</FONT> imagePoints<FONT COLOR=black>,</FONT>
                        <FONT COLOR=blue>double</FONT> focalLength<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvTermCriteria</FONT> criteria<FONT COLOR=black>,</FONT>
                        CvMatr32f rotation<FONT COLOR=black>,</FONT> CvVect32f translation<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvReleasePOSITObject
//    Purpose:    free CvPOSITObject structure
//    Context:
//    Parameters:
//      ppObject - address of pointer to CvPOSITObject
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvReleasePOSITObject<FONT COLOR=black>(</FONT> CvPOSITObject<FONT COLOR=black>**</FONT>  ppObject <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                                      ViewMorphing                                      *
\****************************************************************************************/</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFindFundamentalMatrix<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>       points1<FONT COLOR=black>,</FONT>
                                        <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>       points2<FONT COLOR=black>,</FONT>
                                        <FONT COLOR=blue>int</FONT>        numpoints<FONT COLOR=black>,</FONT>
                                        <FONT COLOR=blue>int</FONT>        method<FONT COLOR=black>,</FONT>
                                        CvMatrix3<FONT COLOR=black>*</FONT> matrix<FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMakeScanlines<FONT COLOR=black>(</FONT> CvMatrix3<FONT COLOR=black>*</FONT> matrix<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>CvSize</FONT>     imgSize<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>       scanlines_1<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>       scanlines_2<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>       lens_1<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>       lens_2<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>       numlines<FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvPreWarpImage<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>       numLines<FONT COLOR=black>,</FONT>
                               <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT>
                               <FONT COLOR=darkmagenta>uchar</FONT><FONT COLOR=black>*</FONT>    dst<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>      dst_nums<FONT COLOR=black>,</FONT>
                               <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>      scanlines<FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvFindRuns<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>    numLines<FONT COLOR=black>,</FONT>
                           <FONT COLOR=darkmagenta>uchar</FONT><FONT COLOR=black>*</FONT> prewarp_1<FONT COLOR=black>,</FONT>
                           <FONT COLOR=darkmagenta>uchar</FONT><FONT COLOR=black>*</FONT> prewarp_2<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   line_lens_1<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   line_lens_2<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   runs_1<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   runs_2<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   num_runs_1<FONT COLOR=black>,</FONT>
                           <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   num_runs_2<FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvDynamicCorrespondMulti<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>  lines<FONT COLOR=black>,</FONT>
                                         <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> first<FONT COLOR=black>,</FONT>
                                         <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> first_runs<FONT COLOR=black>,</FONT>
                                         <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> second<FONT COLOR=black>,</FONT>
                                         <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> second_runs<FONT COLOR=black>,</FONT>
                                         <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> first_corr<FONT COLOR=black>,</FONT>
                                         <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> second_corr<FONT COLOR=black>);</FONT>


OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMakeAlphaScanlines<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>  scanlines_1<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>  scanlines_2<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>  scanlines_a<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>  lens<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT>   numlines<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>float</FONT> alpha<FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvMorphEpilinesMulti<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>    lines<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>uchar</FONT><FONT COLOR=black>*</FONT> first_pix<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   first_num<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>uchar</FONT><FONT COLOR=black>*</FONT> second_pix<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   second_num<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=darkmagenta>uchar</FONT><FONT COLOR=black>*</FONT> dst_pix<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   dst_num<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>float</FONT>  alpha<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   first<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   first_runs<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   second<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   second_runs<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   first_corr<FONT COLOR=black>,</FONT>
                                     <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>   second_corr<FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvDeleteMoire<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT>  img<FONT COLOR=black>);</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvPostWarpImage<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT>       numLines<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>uchar</FONT><FONT COLOR=black>*</FONT>    src<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>      src_nums<FONT COLOR=black>,</FONT>
                                <FONT COLOR=darkmagenta>IplImage</FONT><FONT COLOR=black>*</FONT> img<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT>      scanlines<FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/****************************************************************************************\
*                                      Matrix Functions                                  *
\****************************************************************************************/</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//   Name:    cvmAlloc
//   Purpose:
//      Allocates memory for matrix elements
//   Context:
//   Parameters:
//      mat - pointer to the matrix structure
//   Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmAlloc<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> mat <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//   Name:    cvmAllocArray
//   Purpose:
//      Allocates memory for matrix array elements
//   Context:
//   Parameters:
//      mat - pointer to the matrix array structure
//   Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmAllocArray<FONT COLOR=black>(</FONT> CvMatArray<FONT COLOR=black>*</FONT> mat <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//   Name:    cvmFree
//   Purpose:
//     Deallocates memory, allocated by cvmAlloc
//   Context:
//   Parameters:
//      mat - pointer to the matrix array  structure
//   Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmFree<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> mat <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//   Name:    cvmFreeArray
//   Purpose:
//     Deallocates memory, allocated by cvmAllocArray
//   Context:
//   Parameters:
//     mat - pointer to the matrix array  structure
//   Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmFreeArray<FONT COLOR=black>(</FONT> CvMatArray<FONT COLOR=black>*</FONT> mat <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmAdd
//    Purpose:    Adds one matrix to another
//    Context:
//    Parameters:
//      srcA - first source matrix
//      srcB - second source matrix
//      dst  - destination matrix
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmAdd<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> srcA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> srcB<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmSub
//    Purpose:    Subtracts one matrix from another
//    Context:
//    Parameters:
//      srcA - first source matrix
//      srcB - second source matrix 
//      dst  - destination matrix: dst = srcA - srcB
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmSub<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> srcA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> srcB<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmScale
//    Purpose:    Multiplies all matrix elements by a scalar value
//    Context:
//    Parameters:
//      src -  source matrix
//      dst - destination matrix
//      alpha  - scale factor
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmScale<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT> <FONT COLOR=blue>double</FONT> alpha <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmDotProduct
//    Purpose:    Evaluates dot product of two vectors
//    Context:
//    Parameters:
//      srcA - first source vector
//      srcB - second source vector
//
//    Returns:
//      Dot product of srcA and srcB
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvmDotProduct<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> srcA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> srcB <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmCrossProduct
//    Purpose:    Evaluates cross product of two 3x1 vectors
//    Context:
//    Parameters: srcA - first source vector
//                srcB - second source vector
//                dst  - destination vector
//    Returns:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmCrossProduct<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> srcA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> srcB<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> dst <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmMul
//    Purpose:    Evaluates Product of two matrices
//    Context:
//    Parameters:
//      srcA - first source matrix
//      srcB - second source matrix
//      dst  - destination matrix
//    Returns:
//
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvmMul<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> srcA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> srcB<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> dst <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmMulTransposed
//    Purpose:    Evaluates product of matix by itself transposed
//    Context:
//    Parameters:
//      src - source matrix (A)
//      dst - destination matrix
//      order - determines the order of multiplication
//              if order = 0 function performs A*At
//              if order = 1  - At*A
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmMulTransposed<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> order <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmTranspose
//    Purpose:    Transposes matrix
//    Context:
//    Parameters:
//      src - source matrix
//      dst - destination matrix
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmTranspose<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> dst <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmInvert
//    Purpose:    Matrix inversion
//    Context:
//    Parameters:
//      src - source matrix
//      dst - destination matrix
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmInvert<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> dst <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:     cvmTrace
//    Purpose:  Calculates trace of matrix (sum of diagonal elements)
//    Context:
//    Parameters:
//      mat - source matrix
//    Returns:
//      trace of matrix
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvmTrace<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> mat<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmDet
//    Purpose:    Calculates determinant of the matrix
//    Context:
//    Parameters:
//      mat - source matrix
//    Returns:
//      Matrix determinant
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT> cvmDet<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> mat <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmSVD
//    Purpose:    Calculates Singular Value Decomposition for the matrix
//       A = [a][w][vT].
//       Input A matrix is this.  Output orthogonal a matrix overwrites this.
//       Output n x n w matrix is diagonal.  Output n x n v matrix is orthogonal.
//       Ainverse = [v][diag(1/w)][aT].  Inverses of a and v equal their transposes.
//       Scratch 1 x n rv1 vector is used by this function.
//       w~=0 elements may have 1/w set to 0 to solve singular system.
//    Context:
//    Parameters: src -  source matrix
//                w - first  destination matrix
//                v - second destination matrix
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvmSVD<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> w<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> v<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmEigenVV
//    Purpose:    Finds eigenvalues & eigenvectors of a symmetric matrix:
//    Context:
//    Parameters:
//      src - source symmetric matrix,
//      evects - matrix of its eigenvectors
//               (i-th row is an i-th eigenvector),
//      evals - vector of its eigenvalues
//              (i-th element is an i-th eigenvalue),
//      eps - accuracy of diagonalization.
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmEigenVV<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> evects<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> evals<FONT COLOR=black>,</FONT><FONT COLOR=blue>double</FONT> eps<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmCopy
//    Purpose:    Copies matrix
//    Context:
//    Parameters:
//      src - source matrix
//      dst - destination matrix
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmCopy<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> dst<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmSetZero
//    Purpose:    Clears all the matrix elements (sets them to 0)
//    Context:
//    Parameters: mat  - matrix
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmSetZero<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> mat<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmSetIdentity
//    Purpose:    Fills identity matrix
//    Context:
//    Parameters:
//      mat - matrix
//    Returns:
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvmSetIdentity<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> mat <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmMahalanobis
//    Purpose:    Calculates Mahalanobis(weighted) distance.
//    Context:
//    Parameters:
//      srcA - first source vector
//      srcB - second source vector
//      matr - covariance matrix
//    Returns:
//      Mahalanobis distance
//    Notes:
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>double</FONT>  cvmMahalanobis<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> srcA<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT>srcB<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> mat<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F///////////////////////////////////////////////////////////////////////////////////////
//    Name:       cvmPerspectiveProject
//    Purpose:    Applies perspective transform to the array of vectors
//    Context:
//    Parameters: mat - matrix
//                src - source array
//                dst - destination array
//    Returns:
//    Notes:
//F*/</FONT>

OPENCVAPI  <FONT COLOR=blue>void</FONT>   cvmPerspectiveProject<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> mat<FONT COLOR=black>,</FONT>CvMatArray<FONT COLOR=black>*</FONT> src<FONT COLOR=black>,</FONT> CvMatArray<FONT COLOR=black>*</FONT> dst<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                      CONDENSATION                              *
\****************************************************************************************/</FONT>
OPENCVAPI CvConDensation<FONT COLOR=black>*</FONT>  cvCreateConDensation<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> DP<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> MP<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> SamplesNum<FONT COLOR=black>);</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvReleaseConDensation<FONT COLOR=black>(</FONT> CvConDensation<FONT COLOR=black>**</FONT> ConDensation<FONT COLOR=black>);</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvConDensUpdateByTime<FONT COLOR=black>(</FONT> CvConDensation<FONT COLOR=black>*</FONT> ConDens<FONT COLOR=black>);</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvConDensInitSampleSet<FONT COLOR=black>(</FONT> CvConDensation<FONT COLOR=black>*</FONT> conDens<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> lowerBound<FONT COLOR=black>,</FONT><FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> upperBound<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/****************************************************************************************\
*                                      Kalman Filtering                                  *
\****************************************************************************************/</FONT>

OPENCVAPI CvKalman<FONT COLOR=black>*</FONT> cvCreateKalman<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> DynamParams<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> MeasureParams<FONT COLOR=black>);</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvReleaseKalman<FONT COLOR=black>(</FONT> CvKalman<FONT COLOR=black>**</FONT> Kalman<FONT COLOR=black>);</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvKalmanUpdateByTime<FONT COLOR=black>(</FONT> CvKalman<FONT COLOR=black>*</FONT> Kalman<FONT COLOR=black>);</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT>  cvKalmanUpdateByMeasurement<FONT COLOR=black>(</FONT> CvKalman<FONT COLOR=black>*</FONT> Kalman<FONT COLOR=black>,</FONT> <FONT COLOR=darkmagenta>CvMat</FONT><FONT COLOR=black>*</FONT> Measurement<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/*F//////////////////////////////////////////////////////////////////////////////////////
//    Name: cvLoadPrimitives
//    Purpose: The function loads primitives
//    Context:
//    Parameters:  dllName        - name of dll to be loaded(without prefix) or NULL
//                                  for default dll
//                 processor_type - needep processor type or NULL for automatic processor
//                                  detection
//    Return value: number of loaded functions
//    Notes:   full dll name is consists from dllName + processor_type.dll(or
//             dllName + processor_type + "d".dll for debug configuration)
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT>  cvLoadPrimitives<FONT COLOR=black>();</FONT>
OPENCVAPI  <FONT COLOR=blue>int</FONT> cvFillInetrnalFuncsTable<FONT COLOR=black>(</FONT><FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> table<FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*F//////////////////////////////////////////////////////////////////////////////////////
//    Name: cvGetLibraryInfo
//    Purpose: The function returns information about current version of library and
//             loaded/non loaded primitives dll
//    Context:
//    Parameters:  version  - pointer to pointer to version of OpenCV - build data
//                           (or NULL if don't needed)
//                 loaded   - pointer to flag of loaded primitives, nonzero value
//                            after returning from function indicates that primitives
//                            are loaded(NULL if don't needed)
//                 dll_name - pointer to full name of loaded dll, without path
//                           (NULL if don't needed)
//
//    Notes:   If interToggle=0, interpolation disabled;
//             else bilinear interpolation is used.
//F*/</FONT>
OPENCVAPI  <FONT COLOR=blue>void</FONT>  cvGetLibraryInfo<FONT COLOR=black>(</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>**</FONT> version<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> loaded<FONT COLOR=black>,</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>**</FONT> dll_name<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/* **************************** Error handling ************************* */</FONT>

<FONT COLOR=darkgreen>/* /////////////////////////////////////////////////////////////////////////
// Name:       cvGetErrStatus
// Purpose:    Gets last error status
// Returns:
// Parameters:
//
// Notes:
*/</FONT>
OPENCVAPI <FONT COLOR=darkmagenta>CVStatus</FONT> cvGetErrStatus<FONT COLOR=black>(</FONT> <FONT COLOR=blue>void</FONT> <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/* /////////////////////////////////////////////////////////////////////////
// Name:       cvSetErrStatus
// Purpose:    Sets error status
// Returns:
// Parameters:
//
// Notes:
*/</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvSetErrStatus<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CVStatus</FONT> status <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/* /////////////////////////////////////////////////////////////////////////
// Name:       cvGetErrMode, cvSetErrMode
// Purpose:    gets/sets error mode
// Returns:
// Parameters:
//
// Notes:
*/</FONT>
OPENCVAPI <FONT COLOR=blue>int</FONT>  cvGetErrMode<FONT COLOR=black>(</FONT> <FONT COLOR=blue>void</FONT> <FONT COLOR=black>);</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvSetErrMode<FONT COLOR=black>(</FONT> <FONT COLOR=blue>int</FONT> mode <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/* /////////////////////////////////////////////////////////////////////////
// Name:       cvError
// Purpose:    performs basic error handling
// Returns:    last status
// Parameters:
//
// Notes:
*/</FONT>

OPENCVAPI <FONT COLOR=darkmagenta>CVStatus</FONT> cvError<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CVStatus</FONT> code<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>func<FONT COLOR=black>,</FONT>
                         <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>context<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>file<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> line<FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/* /////////////////////////////////////////////////////////////////////////
// Name:       cvErrorStr
// Purpose:    translates an error status code into a textual description
// Returns:
// Parameters:
//
// Notes:
*/</FONT>
OPENCVAPI <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT> cvErrorStr<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CVStatus</FONT> status <FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/* /////////////////////////////////////////////////////////////////////////
// Name:       iplRedirectError
// Purpose:    assigns a new error-handling function
// Returns:    old error-handling function
// Parameters: new error-handling function
//
// Notes:
*/</FONT>

OPENCVAPI CVErrorCallBack cvRedirectError<FONT COLOR=black>(</FONT>CVErrorCallBack cvErrorFunc<FONT COLOR=black>);</FONT>


<FONT COLOR=darkgreen>/*-----------------  Predefined error-handling functions  -----------------*/</FONT>

<FONT COLOR=darkgreen>/*
    Output to:
        cvNulDevReport - nothing
        cvStdErrReport - console(printf)
        cvGuiBoxReport - MessageBox(WIN32)
*/</FONT>
OPENCVAPI <FONT COLOR=darkmagenta>CVStatus</FONT> cvNulDevReport<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CVStatus</FONT> status<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>funcName<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>context<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>file<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> line <FONT COLOR=black>);</FONT>

OPENCVAPI <FONT COLOR=darkmagenta>CVStatus</FONT> cvStdErrReport<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CVStatus</FONT> status<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>funcName<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>context<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>file<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> line <FONT COLOR=black>);</FONT>

OPENCVAPI <FONT COLOR=darkmagenta>CVStatus</FONT> cvGuiBoxReport<FONT COLOR=black>(</FONT> <FONT COLOR=darkmagenta>CVStatus</FONT> status<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>funcName<FONT COLOR=black>,</FONT>
                                <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>context<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT> <FONT COLOR=black>*</FONT>file<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> line<FONT COLOR=black>);</FONT>

OPENCVAPI <FONT COLOR=blue>void</FONT> cvGetCallStack<FONT COLOR=black>(</FONT>CvStackRecord<FONT COLOR=black>**</FONT> stack<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> size<FONT COLOR=black>);</FONT>

OPENCVAPI <FONT COLOR=blue>void</FONT> cvStartProfile<FONT COLOR=black>(</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT> call<FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT> file<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> line <FONT COLOR=black>);</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvEndProfile<FONT COLOR=black>(</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT> file<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT> line <FONT COLOR=black>);</FONT>

<FONT COLOR=darkgreen>/* management functions */</FONT>
OPENCVAPI <FONT COLOR=blue>void</FONT> cvSetProfile<FONT COLOR=black>(</FONT> <FONT COLOR=blue>void</FONT> <FONT COLOR=black>(</FONT>CV_CDECL <FONT COLOR=black>*</FONT>startprofile_f<FONT COLOR=black>)(</FONT><FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT><FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT><FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>),</FONT>
                          <FONT COLOR=blue>void</FONT> <FONT COLOR=black>(</FONT>CV_CDECL <FONT COLOR=black>*</FONT>endprofile_f<FONT COLOR=black>)(</FONT><FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT><FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT> 
 
OPENCVAPI <FONT COLOR=blue>void</FONT> cvRemoveProfile<FONT COLOR=black>();</FONT>                  

OPENCVAPI <FONT COLOR=blue>void</FONT> cvSetMemoryManager<FONT COLOR=black>(</FONT> <FONT COLOR=blue>void</FONT><FONT COLOR=black>*</FONT> <FONT COLOR=black>(</FONT>CV_CDECL <FONT COLOR=black>*</FONT>_cvAlloc_<FONT COLOR=black>)(</FONT><FONT COLOR=blue>int</FONT><FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT><FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>),</FONT>
                                <FONT COLOR=blue>void</FONT>  <FONT COLOR=black>(</FONT>CV_CDECL <FONT COLOR=black>*</FONT>_cvFree_ <FONT COLOR=black>)(</FONT><FONT COLOR=blue>void</FONT><FONT COLOR=black>**</FONT><FONT COLOR=black>,</FONT> <FONT COLOR=blue>const</FONT> <FONT COLOR=blue>char</FONT><FONT COLOR=black>*</FONT><FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>)</FONT> <FONT COLOR=black>);</FONT>

OPENCVAPI <FONT COLOR=blue>void</FONT> cvRemoveMemoryManager<FONT COLOR=black>();</FONT>

OPENCVAPI <FONT COLOR=blue>void</FONT> cvGetCallStack<FONT COLOR=black>(</FONT>CvStackRecord<FONT COLOR=black>**</FONT> stack<FONT COLOR=black>,</FONT> <FONT COLOR=blue>int</FONT><FONT COLOR=black>*</FONT> size<FONT COLOR=black>);</FONT>

<FONT COLOR=darkblue>#endif <FONT COLOR=darkgreen>/*_CV_H_*/</FONT></FONT>
</PRE>
</BODY>
</HTML>
