#include "UniKey.h"
#include "stdio.h"
#include "string.h"
struct usbKeyData {
	int timeLimited;
	int timeRemain;
	int spectrafitEnabled;
};
int main( int, char ** ) {
	WORD handle, zp1,zp2,zp3,zp4, count;
	DWORD lp1, lp2, hardwareID, retcode, ipAddress, countDW;

	zp1 = 0x0000;  // put your seed-generated (or factory default) password here.
	zp2 = 0x1111;
	zp3 = 0x2222;
	zp4 = 0x3333;

	zp1 = 0xb81e;  // passwords as generated by seed, these pwds are unique to KinTek software
	zp2 = 0x3efc;
	zp3 = 0x2daf;
	zp4 = 0x3fa5;

	// find dongle
	retcode = UniKey_Find( &handle, &lp1, &lp2 );
	if (!retcode) {
		hardwareID = lp1;
		printf( "Hardware ID = %08X\n", hardwareID );

		// open dongle: this should require a correct password
		retcode = UniKey_Vender_Logon( &handle, &zp1, &zp2, &zp3, &zp4 );
		if( !retcode ) {
			// Dongle has correct password.
			printf( "Hardware is programmed with correct password.\n" );

			// READ info from memory
			usbKeyData usbData;
			memset( &usbData, 0, sizeof( usbData ) );
			zp1 = 0;
			zp2 = sizeof( usbData );
			retcode = UniKey_Read_Memory( &handle, &zp1, &zp2, (BYTE*)&usbData );
			if( retcode ) {
				printf( "READ_MEMORY error code %d\n", retcode );
				return 0;
			}

			// Try the network API

			/*	UniKey NET API				
			long UniKey_Get_Dongle_Location(WORD* pHandle, DWORD* pIPAddress);
			long UniKey_Get_Cli_Num(WORD* pHandle, DWORD* cnt);
			long UniKey_Get_Max_Num(WORD* pHandle, WORD* cnt);
			long UniKey_Set_Max_Num(WORD *pHandle, WORD *cnt);
			*/
			ipAddress = 0;
			retcode = UniKey_Get_Dongle_Location( &handle, &ipAddress );
				// This is returning 0 for the ipAddress
			if( retcode ) {
				printf( "UniKey_Get_Dongle_Location error code %d\n", retcode );
			}
			else {
				printf( "UniKey_Get_Dongle_Location() ipAddress is %d\n", ipAddress );
			}

/*  This is part of a server library only?  I get a link error trying to call this
			countDW = 0;
			retcode = UniKey_Get_Cli_Num( &handle, &countDW );
			if( retcode ) {
				printf( "UniKey_Get_Cli_Num error code %d\n", retcode );
			}
			else {
				printf( "UniKey_Get_Cli_Num() count is %d\n", countDW );
			}
*/

			count = 0;
			retcode = UniKey_Get_Max_Num( &handle, &count );
				// This is returning error code 205 (function not available)
			if( retcode ) {
				printf( "UniKey_Get_Max_Num error code %d\n", retcode );
			}
			else {
				printf( "UniKey_Get_Max_Num() count is %d\n", count );
			}

			count++;
			retcode = UniKey_Set_Max_Num( &handle, &count );
				// This is returning error code 205 (function not available)
			if( retcode ) {
				printf( "UniKey_Set_Max_Num error code %d\n", retcode );
			}
			else {
				printf( "UniKey_Set_Max_Num() count is %d\n", count );
			}
		}
		else {
			// Unable to logon to key: aborting...
			printf("UNIKEY_LOGON error code: %d \n", retcode);
			return 0;
		}
	}
	else {
		// No UniKey key attached!
		printf("No Key attached? UNIKEY_FIND error code: %d \n", retcode);
		return 0;
	}
	UniKey_Logoff( &handle );
	return 1;
}
